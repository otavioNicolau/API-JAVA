<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PdfProcessingServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PDF Processor Infrastructure</a> &gt; <a href="index.source.html" class="el_package">com.pdfprocessor.infrastructure.adapter</a> &gt; <span class="el_source">PdfProcessingServiceImpl.java</span></div><h1>PdfProcessingServiceImpl.java</h1><pre class="source lang-java linenums">package com.pdfprocessor.infrastructure.adapter;

import com.pdfprocessor.domain.model.Job;
import com.pdfprocessor.domain.model.JobOperation;
import com.pdfprocessor.domain.port.PdfProcessingService;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.imageio.ImageIO;
import org.apache.pdfbox.Loader;
import org.apache.pdfbox.multipdf.PDFMergerUtility;
import org.apache.pdfbox.multipdf.Splitter;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.encryption.AccessPermission;
import org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.font.Standard14Fonts;
import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
import org.apache.pdfbox.pdmodel.graphics.state.PDExtendedGraphicsState;
import org.apache.pdfbox.rendering.ImageType;
import org.apache.pdfbox.rendering.PDFRenderer;
import org.apache.pdfbox.text.PDFTextStripper;
import org.springframework.stereotype.Component;

/**
 * Implementação do serviço de processamento de PDF usando PDFBox. TODO: Implementar operações reais
 * de PDF.
 */
@Component
<span class="fc" id="L43">public class PdfProcessingServiceImpl implements PdfProcessingService {</span>

  private static final List&lt;JobOperation&gt; SUPPORTED_OPERATIONS;

  static {
<span class="fc" id="L48">    SUPPORTED_OPERATIONS =</span>
<span class="fc" id="L49">        List.of(</span>
            JobOperation.MERGE,
            JobOperation.SPLIT,
            JobOperation.ROTATE,
            JobOperation.WATERMARK,
            JobOperation.ENCRYPT,
            JobOperation.DECRYPT,
            JobOperation.EXTRACT_TEXT,
            JobOperation.EXTRACT_METADATA,
            // Operações avançadas
            JobOperation.PDF_CROP,
            JobOperation.PDF_REORDER,
            JobOperation.PDF_RESIZE,
            JobOperation.COMPRESS,
            JobOperation.PDF_TO_IMAGES,
            JobOperation.IMAGES_TO_PDF,
            JobOperation.PDF_COMPARE,
            JobOperation.PDF_CREATE,
            // Operações de edição e proteção
            JobOperation.PDF_EDIT,
            JobOperation.PDF_PROTECT,
            JobOperation.PDF_UNLOCK);
<span class="fc" id="L71">  }</span>

  @Override
  public String processJob(Job job) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (job == null) {</span>
<span class="fc" id="L76">      throw new IllegalArgumentException(&quot;Job cannot be null&quot;);</span>
    }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (job.getOperation() == null) {</span>
<span class="nc" id="L79">      throw new IllegalArgumentException(&quot;Job operation cannot be null&quot;);</span>
    }

<span class="fc" id="L82">    System.out.println(&quot;Processing job: &quot; + job.getId() + &quot; with operation: &quot; + job.getOperation());</span>

    // Debug: verificar se job e seus campos não são null
<span class="fc" id="L85">    System.out.println(&quot;DEBUG: Job ID: &quot; + job.getId());</span>
<span class="fc" id="L86">    System.out.println(&quot;DEBUG: Job Operation: &quot; + job.getOperation());</span>
<span class="fc" id="L87">    System.out.println(&quot;DEBUG: Job InputFiles: &quot; + job.getInputFiles());</span>
<span class="fc" id="L88">    System.out.println(&quot;DEBUG: Job Options: &quot; + job.getOptions());</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">    if (job.getInputFiles() == null) {</span>
<span class="nc" id="L91">      throw new IllegalArgumentException(&quot;Job input files cannot be null&quot;);</span>
    }

<span class="fc bfc" id="L94" title="All 2 branches covered.">    if (job.getInputFiles().isEmpty()) {</span>
<span class="fc" id="L95">      throw new IllegalArgumentException(&quot;Job input files cannot be empty&quot;);</span>
    }

    try {
<span class="nc bnc" id="L99" title="All 20 branches missed.">      return switch (job.getOperation()) {</span>
<span class="nc" id="L100">        case MERGE -&gt; processMerge(job);</span>
<span class="nc" id="L101">        case SPLIT -&gt; processSplit(job);</span>
<span class="nc" id="L102">        case ROTATE -&gt; processRotate(job);</span>
<span class="nc" id="L103">        case WATERMARK -&gt; processWatermark(job);</span>
<span class="nc" id="L104">        case ENCRYPT -&gt; processEncrypt(job);</span>
<span class="nc" id="L105">        case DECRYPT -&gt; processDecrypt(job);</span>
<span class="nc" id="L106">        case EXTRACT_TEXT -&gt; processExtractText(job);</span>
<span class="nc" id="L107">        case EXTRACT_METADATA -&gt; processExtractMetadata(job);</span>
          // Operações avançadas
<span class="nc" id="L109">        case PDF_CROP -&gt; processPdfCrop(job);</span>
<span class="nc" id="L110">        case PDF_REORDER -&gt; processPdfReorder(job);</span>
<span class="nc" id="L111">        case PDF_RESIZE -&gt; processPdfResize(job);</span>
<span class="nc" id="L112">        case COMPRESS -&gt; processCompress(job);</span>
<span class="nc" id="L113">        case PDF_TO_IMAGES -&gt; processPdfToImages(job);</span>
<span class="nc" id="L114">        case IMAGES_TO_PDF -&gt; processImagesToPdf(job);</span>
<span class="nc" id="L115">        case PDF_COMPARE -&gt; processPdfCompare(job);</span>
<span class="nc" id="L116">        case PDF_CREATE -&gt; processPdfCreate(job);</span>
        // Operações de edição e proteção
<span class="nc" id="L118">        case PDF_EDIT -&gt; processPdfEdit(job);</span>
<span class="nc" id="L119">        case PDF_PROTECT -&gt; processPdfProtect(job);</span>
<span class="nc" id="L120">        case PDF_UNLOCK -&gt; processPdfUnlock(job);</span>
        default -&gt;
<span class="nc" id="L122">            throw new UnsupportedOperationException(</span>
<span class="nc" id="L123">                &quot;Operation not supported: &quot; + job.getOperation());</span>
      };
<span class="fc" id="L125">    } catch (IllegalArgumentException e) {</span>
      // Re-throw IllegalArgumentException as-is for proper test validation
<span class="fc" id="L127">      throw e;</span>
<span class="nc" id="L128">    } catch (Exception e) {</span>
<span class="nc" id="L129">      throw new RuntimeException(&quot;Error processing job: &quot; + job.getId(), e);</span>
    }
  }

  private String processMerge(Job job) throws IOException {
<span class="fc" id="L134">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="fc" id="L135">    System.out.println(&quot;DEBUG: Input files for merge: &quot; + inputFiles);</span>

<span class="pc bpc" id="L137" title="2 of 4 branches missed.">    if (inputFiles == null || inputFiles.size() &lt; 2) {</span>
<span class="nc" id="L138">      throw new IllegalArgumentException(&quot;MERGE operation requires at least 2 input files&quot;);</span>
    }

    // Criar diretório de resultado
<span class="fc" id="L142">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="fc" id="L143">    Files.createDirectories(resultDir);</span>

<span class="fc" id="L145">    String resultPath = resultDir.resolve(&quot;result_&quot; + job.getId() + &quot;.pdf&quot;).toString();</span>
<span class="fc" id="L146">    System.out.println(&quot;DEBUG: Result path: &quot; + resultPath);</span>

<span class="fc" id="L148">    PDFMergerUtility merger = new PDFMergerUtility();</span>
<span class="fc" id="L149">    merger.setDestinationFileName(resultPath);</span>

    // Adicionar todos os arquivos de entrada
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">    for (String inputFile : inputFiles) {</span>
<span class="fc" id="L153">      File file = new File(inputFile);</span>
<span class="fc" id="L154">      System.out.println(</span>
          &quot;DEBUG: Checking file: &quot;
              + inputFile
              + &quot;, exists: &quot;
<span class="fc" id="L158">              + file.exists()</span>
              + &quot;, size: &quot;
<span class="fc" id="L160">              + file.length());</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">      if (!file.exists()) {</span>
<span class="fc" id="L162">        throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
      }
<span class="nc" id="L164">      merger.addSource(file);</span>
<span class="nc" id="L165">      System.out.println(&quot;DEBUG: Added source file: &quot; + inputFile);</span>
<span class="nc" id="L166">    }</span>

<span class="nc" id="L168">    System.out.println(&quot;DEBUG: Starting merge operation...&quot;);</span>
<span class="nc" id="L169">    merger.mergeDocuments(null);</span>
<span class="nc" id="L170">    System.out.println(&quot;DEBUG: Merge completed&quot;);</span>

    // Verificar se o arquivo de resultado foi criado
<span class="nc" id="L173">    File resultFile = new File(resultPath);</span>
<span class="nc" id="L174">    System.out.println(</span>
<span class="nc" id="L175">        &quot;DEBUG: Result file exists: &quot; + resultFile.exists() + &quot;, size: &quot; + resultFile.length());</span>

<span class="nc" id="L177">    System.out.println(&quot;Merged &quot; + inputFiles.size() + &quot; files into: &quot; + resultPath);</span>
<span class="nc" id="L178">    return resultPath;</span>
  }

  private String processSplit(Job job) throws IOException {
<span class="nc" id="L182">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L184">      throw new IllegalArgumentException(&quot;SPLIT operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L187">    String inputFile = inputFiles.get(0); // SPLIT trabalha com apenas um arquivo</span>
<span class="nc" id="L188">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L190">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L194">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="nc" id="L195">    Files.createDirectories(resultDir);</span>

    // Obter opções de split
<span class="nc" id="L198">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    String pages = options != null ? (String) options.get(&quot;pages&quot;) : &quot;all&quot;;</span>

<span class="nc" id="L201">    try (PDDocument document = Loader.loadPDF(file)) {</span>
<span class="nc" id="L202">      int totalPages = document.getNumberOfPages();</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">      if (&quot;all&quot;.equals(pages)) {</span>
        // Dividir em páginas individuais
<span class="nc" id="L206">        return splitAllPages(document, resultDir, totalPages);</span>
      } else {
        // Dividir por intervalo específico (ex: &quot;1-3&quot;, &quot;5&quot;, &quot;1,3,5-7&quot;)
<span class="nc" id="L209">        return splitByRange(document, resultDir, pages, totalPages);</span>
      }
<span class="nc bnc" id="L211" title="All 2 branches missed.">    }</span>
  }

  private String splitAllPages(PDDocument document, Path resultDir, int totalPages)
      throws IOException {
<span class="nc" id="L216">    Splitter splitter = new Splitter();</span>
<span class="nc" id="L217">    List&lt;PDDocument&gt; pages = splitter.split(document);</span>

<span class="nc" id="L219">    List&lt;String&gt; resultFiles = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">    for (int i = 0; i &lt; pages.size(); i++) {</span>
<span class="nc" id="L222">      String fileName = String.format(&quot;page_%03d.pdf&quot;, i + 1);</span>
<span class="nc" id="L223">      Path filePath = resultDir.resolve(fileName);</span>

<span class="nc" id="L225">      try (PDDocument pageDoc = pages.get(i)) {</span>
<span class="nc" id="L226">        pageDoc.save(filePath.toFile());</span>
<span class="nc" id="L227">        resultFiles.add(filePath.toString());</span>
      }
    }

<span class="nc" id="L231">    System.out.println(&quot;Split &quot; + totalPages + &quot; pages into individual files in: &quot; + resultDir);</span>

    // Retorna o diretório contendo todos os arquivos
<span class="nc" id="L234">    return resultDir.toString();</span>
  }

  private String splitByRange(PDDocument document, Path resultDir, String pages, int totalPages)
      throws IOException {
<span class="nc" id="L239">    List&lt;Integer&gt; pageNumbers = parsePageRange(pages, totalPages);</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">    if (pageNumbers.isEmpty()) {</span>
<span class="nc" id="L242">      throw new IllegalArgumentException(&quot;No valid pages specified in range: &quot; + pages);</span>
    }

    // Criar um novo documento com as páginas especificadas
<span class="nc" id="L246">    try (PDDocument resultDoc = new PDDocument()) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">      for (Integer pageNum : pageNumbers) {</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">        if (pageNum &gt;= 1 &amp;&amp; pageNum &lt;= totalPages) {</span>
<span class="nc" id="L249">          PDPage page = document.getPage(pageNum - 1); // PDFBox usa índice 0</span>
<span class="nc" id="L250">          resultDoc.addPage(page);</span>
        }
<span class="nc" id="L252">      }</span>

<span class="nc" id="L254">      String fileName = &quot;pages_&quot; + pages.replaceAll(&quot;[^0-9,-]&quot;, &quot;_&quot;) + &quot;.pdf&quot;;</span>
<span class="nc" id="L255">      Path filePath = resultDir.resolve(fileName);</span>
<span class="nc" id="L256">      resultDoc.save(filePath.toFile());</span>

<span class="nc" id="L258">      System.out.println(&quot;Split pages &quot; + pages + &quot; into: &quot; + filePath);</span>
<span class="nc" id="L259">      return filePath.toString();</span>
    }
  }

  private List&lt;Integer&gt; parsePageRange(String pages, int totalPages) {
<span class="nc" id="L264">    List&lt;Integer&gt; pageNumbers = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L266" title="All 4 branches missed.">    if (pages == null || pages.trim().isEmpty()) {</span>
<span class="nc" id="L267">      return pageNumbers;</span>
    }

<span class="nc" id="L270">    String[] parts = pages.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">    for (String part : parts) {</span>
<span class="nc" id="L272">      part = part.trim();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (part.contains(&quot;-&quot;)) {</span>
        // Intervalo (ex: &quot;1-3&quot;, &quot;5-10&quot;)
<span class="nc" id="L275">        String[] range = part.split(&quot;-&quot;);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (range.length == 2) {</span>
          try {
<span class="nc" id="L278">            int start = Integer.parseInt(range[0].trim());</span>
<span class="nc" id="L279">            int end = Integer.parseInt(range[1].trim());</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">            for (int i = start; i &lt;= end &amp;&amp; i &lt;= totalPages; i++) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">              if (i &gt;= 1) {</span>
<span class="nc" id="L282">                pageNumbers.add(i);</span>
              }
            }
<span class="nc" id="L285">          } catch (NumberFormatException e) {</span>
<span class="nc" id="L286">            System.err.println(&quot;Invalid page range: &quot; + part);</span>
<span class="nc" id="L287">          }</span>
        }
<span class="nc" id="L289">      } else {</span>
        // Página individual (ex: &quot;5&quot;)
        try {
<span class="nc" id="L292">          int pageNum = Integer.parseInt(part);</span>
<span class="nc bnc" id="L293" title="All 4 branches missed.">          if (pageNum &gt;= 1 &amp;&amp; pageNum &lt;= totalPages) {</span>
<span class="nc" id="L294">            pageNumbers.add(pageNum);</span>
          }
<span class="nc" id="L296">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L297">          System.err.println(&quot;Invalid page number: &quot; + part);</span>
<span class="nc" id="L298">        }</span>
      }
    }

<span class="nc" id="L302">    return pageNumbers;</span>
  }

  private String processRotate(Job job) throws IOException {
<span class="nc" id="L306">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L308">      throw new IllegalArgumentException(&quot;ROTATE operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L311">    String inputFile = inputFiles.get(0); // ROTATE trabalha com apenas um arquivo</span>
<span class="nc" id="L312">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L314">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L318">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="nc" id="L319">    Files.createDirectories(resultDir);</span>

    // Obter opções de rotação
<span class="nc" id="L322">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L324">      throw new IllegalArgumentException(</span>
          &quot;ROTATE operation requires options with 'degrees' parameter&quot;);
    }

<span class="nc" id="L328">    Object degreesObj = options.get(&quot;degrees&quot;);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (degreesObj == null) {</span>
<span class="nc" id="L330">      throw new IllegalArgumentException(</span>
          &quot;ROTATE operation requires 'degrees' parameter (90, 180, 270)&quot;);
    }

    int degrees;
    try {
<span class="nc" id="L336">      degrees = Integer.parseInt(degreesObj.toString());</span>
<span class="nc" id="L337">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L338">      throw new IllegalArgumentException(</span>
          &quot;Invalid degrees value: &quot; + degreesObj + &quot;. Must be 90, 180, or 270&quot;);
<span class="nc" id="L340">    }</span>

<span class="nc bnc" id="L342" title="All 6 branches missed.">    if (degrees != 90 &amp;&amp; degrees != 180 &amp;&amp; degrees != 270) {</span>
<span class="nc" id="L343">      throw new IllegalArgumentException(&quot;Degrees must be 90, 180, or 270. Got: &quot; + degrees);</span>
    }

<span class="nc bnc" id="L346" title="All 2 branches missed.">    String pages = options.get(&quot;pages&quot;) != null ? options.get(&quot;pages&quot;).toString() : &quot;all&quot;;</span>

<span class="nc" id="L348">    String resultPath = resultDir.resolve(&quot;rotated.pdf&quot;).toString();</span>

<span class="nc" id="L350">    try (PDDocument document = Loader.loadPDF(file)) {</span>
<span class="nc" id="L351">      int totalPages = document.getNumberOfPages();</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">      if (&quot;all&quot;.equals(pages)) {</span>
        // Rotacionar todas as páginas
<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (int i = 0; i &lt; totalPages; i++) {</span>
<span class="nc" id="L356">          rotatePage(document.getPage(i), degrees);</span>
        }
<span class="nc" id="L358">        System.out.println(&quot;Rotated all &quot; + totalPages + &quot; pages by &quot; + degrees + &quot; degrees&quot;);</span>
      } else {
        // Rotacionar páginas específicas
<span class="nc" id="L361">        List&lt;Integer&gt; pageNumbers = parsePageRange(pages, totalPages);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (Integer pageNum : pageNumbers) {</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">          if (pageNum &gt;= 1 &amp;&amp; pageNum &lt;= totalPages) {</span>
<span class="nc" id="L364">            rotatePage(document.getPage(pageNum - 1), degrees);</span>
          }
<span class="nc" id="L366">        }</span>
<span class="nc" id="L367">        System.out.println(&quot;Rotated pages &quot; + pages + &quot; by &quot; + degrees + &quot; degrees&quot;);</span>
      }

<span class="nc" id="L370">      document.save(resultPath);</span>
    }

<span class="nc" id="L373">    System.out.println(&quot;Rotation completed. Result saved to: &quot; + resultPath);</span>
<span class="nc" id="L374">    return resultPath;</span>
  }

  private void rotatePage(PDPage page, int degrees) {
<span class="nc" id="L378">    int currentRotation = page.getRotation();</span>
<span class="nc" id="L379">    int newRotation = (currentRotation + degrees) % 360;</span>
<span class="nc" id="L380">    page.setRotation(newRotation);</span>
<span class="nc" id="L381">  }</span>

  private String processWatermark(Job job) throws IOException {
<span class="nc" id="L384">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L386">      throw new IllegalArgumentException(&quot;WATERMARK operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L389">    String inputFile = inputFiles.get(0); // WATERMARK trabalha com apenas um arquivo</span>
<span class="nc" id="L390">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L392">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L396">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="nc" id="L397">    Files.createDirectories(resultDir);</span>

    // Obter opções de watermark
<span class="nc" id="L400">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L402">      throw new IllegalArgumentException(</span>
          &quot;WATERMARK operation requires options with 'text' parameter&quot;);
    }

<span class="nc" id="L406">    String watermarkText = (String) options.get(&quot;text&quot;);</span>
<span class="nc bnc" id="L407" title="All 4 branches missed.">    if (watermarkText == null || watermarkText.trim().isEmpty()) {</span>
<span class="nc" id="L408">      throw new IllegalArgumentException(&quot;WATERMARK operation requires 'text' parameter&quot;);</span>
    }

    // Opções opcionais
    float opacity =
<span class="nc bnc" id="L413" title="All 2 branches missed.">        options.get(&quot;opacity&quot;) != null ? Float.parseFloat(options.get(&quot;opacity&quot;).toString()) : 0.3f;</span>
    int fontSize =
<span class="nc bnc" id="L415" title="All 2 branches missed.">        options.get(&quot;fontSize&quot;) != null ? Integer.parseInt(options.get(&quot;fontSize&quot;).toString()) : 36;</span>
    String position =
<span class="nc bnc" id="L417" title="All 2 branches missed.">        options.get(&quot;position&quot;) != null ? options.get(&quot;position&quot;).toString() : &quot;center&quot;;</span>

<span class="nc" id="L419">    String resultPath = resultDir.resolve(&quot;watermarked.pdf&quot;).toString();</span>

<span class="nc" id="L421">    try (PDDocument document = Loader.loadPDF(file)) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">      for (PDPage page : document.getPages()) {</span>
<span class="nc" id="L423">        addWatermarkToPage(document, page, watermarkText, opacity, fontSize, position);</span>
<span class="nc" id="L424">      }</span>

<span class="nc" id="L426">      document.save(resultPath);</span>
    }

<span class="nc" id="L429">    System.out.println(&quot;Watermark added to PDF. Result saved to: &quot; + resultPath);</span>
<span class="nc" id="L430">    return resultPath;</span>
  }

  private void addWatermarkToPage(
      PDDocument document, PDPage page, String text, float opacity, int fontSize, String position)
      throws IOException {
<span class="nc" id="L436">    try (PDPageContentStream contentStream =</span>
        new PDPageContentStream(
            document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {

      // Configurar transparência
<span class="nc" id="L441">      PDExtendedGraphicsState graphicsState = new PDExtendedGraphicsState();</span>
<span class="nc" id="L442">      graphicsState.setNonStrokingAlphaConstant(opacity);</span>
<span class="nc" id="L443">      contentStream.setGraphicsStateParameters(graphicsState);</span>

      // Configurar fonte e cor
<span class="nc" id="L446">      PDType1Font font = new PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD);</span>
<span class="nc" id="L447">      contentStream.setFont(font, fontSize);</span>
<span class="nc" id="L448">      contentStream.setNonStrokingColor(Color.GRAY);</span>

      // Calcular posição
<span class="nc" id="L451">      float pageWidth = page.getMediaBox().getWidth();</span>
<span class="nc" id="L452">      float pageHeight = page.getMediaBox().getHeight();</span>
<span class="nc" id="L453">      float textWidth = font.getStringWidth(text) / 1000 * fontSize;</span>

      float x, y;
<span class="nc bnc" id="L456" title="All 5 branches missed.">      switch (position.toLowerCase()) {</span>
        case &quot;top-left&quot; -&gt; {
<span class="nc" id="L458">          x = 50;</span>
<span class="nc" id="L459">          y = pageHeight - 50;</span>
<span class="nc" id="L460">        }</span>
        case &quot;top-right&quot; -&gt; {
<span class="nc" id="L462">          x = pageWidth - textWidth - 50;</span>
<span class="nc" id="L463">          y = pageHeight - 50;</span>
<span class="nc" id="L464">        }</span>
        case &quot;bottom-left&quot; -&gt; {
<span class="nc" id="L466">          x = 50;</span>
<span class="nc" id="L467">          y = 50;</span>
<span class="nc" id="L468">        }</span>
        case &quot;bottom-right&quot; -&gt; {
<span class="nc" id="L470">          x = pageWidth - textWidth - 50;</span>
<span class="nc" id="L471">          y = 50;</span>
<span class="nc" id="L472">        }</span>
        default -&gt; { // center
<span class="nc" id="L474">          x = (pageWidth - textWidth) / 2;</span>
<span class="nc" id="L475">          y = pageHeight / 2;</span>
        }
      }

      // Adicionar texto
<span class="nc" id="L480">      contentStream.beginText();</span>
<span class="nc" id="L481">      contentStream.newLineAtOffset(x, y);</span>
<span class="nc" id="L482">      contentStream.showText(text);</span>
<span class="nc" id="L483">      contentStream.endText();</span>
    }
<span class="nc" id="L485">  }</span>

  private String processEncrypt(Job job) throws IOException {
<span class="nc" id="L488">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L490">      throw new IllegalArgumentException(&quot;ENCRYPT operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L493">    String inputFile = inputFiles.get(0); // ENCRYPT trabalha com apenas um arquivo</span>
<span class="nc" id="L494">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L496">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L500">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="nc" id="L501">    Files.createDirectories(resultDir);</span>

    // Obter opções de criptografia
<span class="nc" id="L504">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L506">      throw new IllegalArgumentException(</span>
          &quot;ENCRYPT operation requires options with 'password' parameter&quot;);
    }

<span class="nc" id="L510">    String userPassword = (String) options.get(&quot;password&quot;);</span>
<span class="nc bnc" id="L511" title="All 4 branches missed.">    if (userPassword == null || userPassword.trim().isEmpty()) {</span>
<span class="nc" id="L512">      throw new IllegalArgumentException(&quot;ENCRYPT operation requires 'password' parameter&quot;);</span>
    }

<span class="nc" id="L515">    String ownerPassword = (String) options.get(&quot;ownerPassword&quot;);</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">    if (ownerPassword == null || ownerPassword.trim().isEmpty()) {</span>
<span class="nc" id="L517">      ownerPassword = userPassword; // Usar a mesma senha se não especificada</span>
    }

<span class="nc" id="L520">    String resultPath = resultDir.resolve(&quot;encrypted.pdf&quot;).toString();</span>

<span class="nc" id="L522">    try (PDDocument document = Loader.loadPDF(file)) {</span>
      // Configurar permissões
<span class="nc" id="L524">      AccessPermission accessPermission = new AccessPermission();</span>

      // Opções de permissão (padrão: permitir tudo)
      boolean allowPrint =
<span class="nc bnc" id="L528" title="All 2 branches missed.">          options.get(&quot;allowPrint&quot;) != null</span>
<span class="nc" id="L529">              ? Boolean.parseBoolean(options.get(&quot;allowPrint&quot;).toString())</span>
<span class="nc" id="L530">              : true;</span>
      boolean allowCopy =
<span class="nc bnc" id="L532" title="All 2 branches missed.">          options.get(&quot;allowCopy&quot;) != null</span>
<span class="nc" id="L533">              ? Boolean.parseBoolean(options.get(&quot;allowCopy&quot;).toString())</span>
<span class="nc" id="L534">              : true;</span>
      boolean allowModify =
<span class="nc bnc" id="L536" title="All 2 branches missed.">          options.get(&quot;allowModify&quot;) != null</span>
<span class="nc" id="L537">              ? Boolean.parseBoolean(options.get(&quot;allowModify&quot;).toString())</span>
<span class="nc" id="L538">              : true;</span>

<span class="nc" id="L540">      accessPermission.setCanPrint(allowPrint);</span>
<span class="nc" id="L541">      accessPermission.setCanExtractContent(allowCopy);</span>
<span class="nc" id="L542">      accessPermission.setCanModify(allowModify);</span>

      // Criar política de proteção
<span class="nc" id="L545">      StandardProtectionPolicy protectionPolicy =</span>
          new StandardProtectionPolicy(ownerPassword, userPassword, accessPermission);
<span class="nc" id="L547">      protectionPolicy.setEncryptionKeyLength(128);</span>

      // Aplicar criptografia
<span class="nc" id="L550">      document.protect(protectionPolicy);</span>
<span class="nc" id="L551">      document.save(resultPath);</span>
    }

<span class="nc" id="L554">    System.out.println(&quot;PDF encrypted successfully. Result saved to: &quot; + resultPath);</span>
<span class="nc" id="L555">    return resultPath;</span>
  }

  private String processDecrypt(Job job) throws IOException {
<span class="nc" id="L559">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L561">      throw new IllegalArgumentException(&quot;DECRYPT operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L564">    String inputFile = inputFiles.get(0); // DECRYPT trabalha com apenas um arquivo</span>
<span class="nc" id="L565">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L567">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L571">    Path resultDir = Paths.get(&quot;./storage/&quot; + job.getId());</span>
<span class="nc" id="L572">    Files.createDirectories(resultDir);</span>

    // Obter opções de descriptografia
<span class="nc" id="L575">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L577">      throw new IllegalArgumentException(</span>
          &quot;DECRYPT operation requires options with 'password' parameter&quot;);
    }

<span class="nc" id="L581">    String password = (String) options.get(&quot;password&quot;);</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">    if (password == null || password.trim().isEmpty()) {</span>
<span class="nc" id="L583">      throw new IllegalArgumentException(&quot;DECRYPT operation requires 'password' parameter&quot;);</span>
    }

<span class="nc" id="L586">    String resultPath = resultDir.resolve(&quot;decrypted.pdf&quot;).toString();</span>

<span class="nc" id="L588">    try (PDDocument document = Loader.loadPDF(file, password)) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">      if (document.isEncrypted()) {</span>
        // Remover proteção
<span class="nc" id="L591">        document.setAllSecurityToBeRemoved(true);</span>
      }

<span class="nc" id="L594">      document.save(resultPath);</span>
<span class="nc" id="L595">    } catch (Exception e) {</span>
<span class="nc" id="L596">      throw new RuntimeException(&quot;Failed to decrypt PDF. Invalid password or corrupted file.&quot;, e);</span>
<span class="nc" id="L597">    }</span>

<span class="nc" id="L599">    System.out.println(&quot;PDF decrypted successfully. Result saved to: &quot; + resultPath);</span>
<span class="nc" id="L600">    return resultPath;</span>
  }

  private String processExtractText(Job job) throws IOException {
<span class="nc bnc" id="L604" title="All 2 branches missed.">    if (job.getInputFiles().isEmpty()) {</span>
<span class="nc" id="L605">      throw new IllegalArgumentException(&quot;No input files provided for text extraction&quot;);</span>
    }

<span class="nc" id="L608">    String inputPath = job.getInputFiles().get(0);</span>
<span class="nc" id="L609">    Path resultDir = Paths.get(&quot;storage/jobs&quot;, job.getId(), &quot;results&quot;);</span>
<span class="nc" id="L610">    Files.createDirectories(resultDir);</span>

<span class="nc" id="L612">    String resultFileName = &quot;extracted_text.txt&quot;;</span>
<span class="nc" id="L613">    Path resultPath = resultDir.resolve(resultFileName);</span>

<span class="nc" id="L615">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
<span class="nc" id="L616">      PDFTextStripper textStripper = new PDFTextStripper();</span>

      // Configurar opções se fornecidas
<span class="nc" id="L619">      Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">      if (options.containsKey(&quot;startPage&quot;)) {</span>
<span class="nc" id="L621">        textStripper.setStartPage(((Number) options.get(&quot;startPage&quot;)).intValue());</span>
      }
<span class="nc bnc" id="L623" title="All 2 branches missed.">      if (options.containsKey(&quot;endPage&quot;)) {</span>
<span class="nc" id="L624">        textStripper.setEndPage(((Number) options.get(&quot;endPage&quot;)).intValue());</span>
      }
<span class="nc bnc" id="L626" title="All 2 branches missed.">      if (options.containsKey(&quot;sortByPosition&quot;)) {</span>
<span class="nc" id="L627">        textStripper.setSortByPosition((Boolean) options.get(&quot;sortByPosition&quot;));</span>
      }

<span class="nc" id="L630">      String extractedText = textStripper.getText(document);</span>
<span class="nc" id="L631">      Files.write(resultPath, extractedText.getBytes(StandardCharsets.UTF_8));</span>
    }

<span class="nc" id="L634">    return resultPath.toString();</span>
  }

  private String processExtractMetadata(Job job) throws IOException {
<span class="nc bnc" id="L638" title="All 2 branches missed.">    if (job.getInputFiles().isEmpty()) {</span>
<span class="nc" id="L639">      throw new IllegalArgumentException(&quot;No input files provided for metadata extraction&quot;);</span>
    }

<span class="nc" id="L642">    String inputPath = job.getInputFiles().get(0);</span>
<span class="nc" id="L643">    Path resultDir = Paths.get(&quot;storage/jobs&quot;, job.getId(), &quot;results&quot;);</span>
<span class="nc" id="L644">    Files.createDirectories(resultDir);</span>

<span class="nc" id="L646">    String resultFileName = &quot;metadata.json&quot;;</span>
<span class="nc" id="L647">    Path resultPath = resultDir.resolve(resultFileName);</span>

<span class="nc" id="L649">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
<span class="nc" id="L650">      PDDocumentInformation info = document.getDocumentInformation();</span>
<span class="nc" id="L651">      Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();</span>

      // Informações básicas do documento
<span class="nc" id="L654">      metadata.put(&quot;title&quot;, info.getTitle());</span>
<span class="nc" id="L655">      metadata.put(&quot;author&quot;, info.getAuthor());</span>
<span class="nc" id="L656">      metadata.put(&quot;subject&quot;, info.getSubject());</span>
<span class="nc" id="L657">      metadata.put(&quot;keywords&quot;, info.getKeywords());</span>
<span class="nc" id="L658">      metadata.put(&quot;creator&quot;, info.getCreator());</span>
<span class="nc" id="L659">      metadata.put(&quot;producer&quot;, info.getProducer());</span>

      // Datas
<span class="nc bnc" id="L662" title="All 2 branches missed.">      if (info.getCreationDate() != null) {</span>
<span class="nc" id="L663">        metadata.put(&quot;creationDate&quot;, info.getCreationDate().getTime().toString());</span>
      }
<span class="nc bnc" id="L665" title="All 2 branches missed.">      if (info.getModificationDate() != null) {</span>
<span class="nc" id="L666">        metadata.put(&quot;modificationDate&quot;, info.getModificationDate().getTime().toString());</span>
      }

      // Informações do documento
<span class="nc" id="L670">      metadata.put(&quot;numberOfPages&quot;, document.getNumberOfPages());</span>
<span class="nc" id="L671">      metadata.put(&quot;version&quot;, document.getVersion());</span>
<span class="nc" id="L672">      metadata.put(&quot;isEncrypted&quot;, document.isEncrypted());</span>

      // Converter para JSON
<span class="nc" id="L675">      StringBuilder jsonBuilder = new StringBuilder();</span>
<span class="nc" id="L676">      jsonBuilder.append(&quot;{\n&quot;);</span>
<span class="nc" id="L677">      boolean first = true;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">      for (Map.Entry&lt;String, Object&gt; entry : metadata.entrySet()) {</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (!first) {</span>
<span class="nc" id="L680">          jsonBuilder.append(&quot;,\n&quot;);</span>
        }
<span class="nc" id="L682">        jsonBuilder.append(&quot;  \&quot;&quot;).append(entry.getKey()).append(&quot;\&quot;: &quot;);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (entry.getValue() == null) {</span>
<span class="nc" id="L684">          jsonBuilder.append(&quot;null&quot;);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        } else if (entry.getValue() instanceof String) {</span>
<span class="nc" id="L686">          jsonBuilder</span>
<span class="nc" id="L687">              .append(&quot;\&quot;&quot;)</span>
<span class="nc" id="L688">              .append(entry.getValue().toString().replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;))</span>
<span class="nc" id="L689">              .append(&quot;\&quot;&quot;);</span>
        } else {
<span class="nc" id="L691">          jsonBuilder.append(entry.getValue().toString());</span>
        }
<span class="nc" id="L693">        first = false;</span>
<span class="nc" id="L694">      }</span>
<span class="nc" id="L695">      jsonBuilder.append(&quot;\n}&quot;);</span>

<span class="nc" id="L697">      Files.write(resultPath, jsonBuilder.toString().getBytes(StandardCharsets.UTF_8));</span>
    }

<span class="nc" id="L700">    return resultPath.toString();</span>
  }

  // Operações avançadas de PDF

  private String processPdfCrop(Job job) throws IOException {
<span class="nc" id="L706">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L707" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L708">      throw new IllegalArgumentException(&quot;PDF_CROP operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L711">    String inputPath = inputFiles.get(0);</span>
<span class="nc" id="L712">    File file = new File(inputPath);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L714">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputPath);</span>
    }

<span class="nc" id="L717">    Map&lt;String, Object&gt; options = job.getOptions();</span>

    // Parâmetros de crop
<span class="nc" id="L720">    Number x = (Number) options.getOrDefault(&quot;x&quot;, 0);</span>
<span class="nc" id="L721">    Number y = (Number) options.getOrDefault(&quot;y&quot;, 0);</span>
<span class="nc" id="L722">    Number width = (Number) options.getOrDefault(&quot;width&quot;, 595); // A4 width</span>
<span class="nc" id="L723">    Number height = (Number) options.getOrDefault(&quot;height&quot;, 842); // A4 height</span>
<span class="nc" id="L724">    String pages = (String) options.getOrDefault(&quot;pages&quot;, &quot;all&quot;);</span>

<span class="nc" id="L726">    Path resultPath = Paths.get(&quot;temp&quot;, &quot;result_&quot; + job.getId() + &quot;.pdf&quot;);</span>
<span class="nc" id="L727">    Files.createDirectories(resultPath.getParent());</span>

<span class="nc" id="L729">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
<span class="nc" id="L730">      PDDocument resultDoc = new PDDocument();</span>

      List&lt;Integer&gt; pageNumbers =
<span class="nc bnc" id="L733" title="All 2 branches missed.">          pages.equals(&quot;all&quot;)</span>
<span class="nc" id="L734">              ? getAllPageNumbers(document.getNumberOfPages())</span>
<span class="nc" id="L735">              : parsePageRange(pages, document.getNumberOfPages());</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">      for (int pageNum : pageNumbers) {</span>
<span class="nc" id="L738">        PDPage page = document.getPage(pageNum - 1);</span>
<span class="nc" id="L739">        PDPage newPage = resultDoc.importPage(page);</span>

        // Define a área de crop
<span class="nc" id="L742">        newPage.setCropBox(</span>
            new org.apache.pdfbox.pdmodel.common.PDRectangle(
<span class="nc" id="L744">                x.floatValue(), y.floatValue(), width.floatValue(), height.floatValue()));</span>
<span class="nc" id="L745">      }</span>

<span class="nc" id="L747">      resultDoc.save(resultPath.toFile());</span>
<span class="nc" id="L748">      resultDoc.close();</span>
    }

<span class="nc" id="L751">    return resultPath.toString();</span>
  }

  private String processPdfReorder(Job job) throws IOException {
<span class="nc" id="L755">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L756" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L757">      throw new IllegalArgumentException(&quot;PDF_REORDER operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L760">    String inputPath = inputFiles.get(0);</span>
<span class="nc" id="L761">    File file = new File(inputPath);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L763">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputPath);</span>
    }

<span class="nc" id="L766">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc" id="L767">    String pageOrder = (String) options.get(&quot;page_order&quot;); // Ex: &quot;3,1,2,4&quot;</span>

<span class="nc bnc" id="L769" title="All 4 branches missed.">    if (pageOrder == null || pageOrder.trim().isEmpty()) {</span>
<span class="nc" id="L770">      throw new IllegalArgumentException(&quot;page_order is required for reorder operation&quot;);</span>
    }

<span class="nc" id="L773">    Path resultPath = Paths.get(&quot;temp&quot;, &quot;result_&quot; + job.getId() + &quot;.pdf&quot;);</span>
<span class="nc" id="L774">    Files.createDirectories(resultPath.getParent());</span>

<span class="nc" id="L776">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
<span class="nc" id="L777">      PDDocument resultDoc = new PDDocument();</span>

<span class="nc" id="L779">      String[] orderArray = pageOrder.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">      for (String pageNumStr : orderArray) {</span>
<span class="nc" id="L781">        int pageNum = Integer.parseInt(pageNumStr.trim());</span>
<span class="nc bnc" id="L782" title="All 4 branches missed.">        if (pageNum &lt; 1 || pageNum &gt; document.getNumberOfPages()) {</span>
<span class="nc" id="L783">          throw new IllegalArgumentException(&quot;Invalid page number: &quot; + pageNum);</span>
        }

<span class="nc" id="L786">        PDPage page = document.getPage(pageNum - 1);</span>
<span class="nc" id="L787">        resultDoc.importPage(page);</span>
      }

<span class="nc" id="L790">      resultDoc.save(resultPath.toFile());</span>
<span class="nc" id="L791">      resultDoc.close();</span>
    }

<span class="nc" id="L794">    return resultPath.toString();</span>
  }

  private String processPdfResize(Job job) throws IOException {
<span class="nc" id="L798">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L800">      throw new IllegalArgumentException(&quot;PDF_RESIZE operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L803">    String inputPath = inputFiles.get(0);</span>
<span class="nc" id="L804">    File file = new File(inputPath);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L806">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputPath);</span>
    }

<span class="nc" id="L809">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc" id="L810">    String pageSize = (String) options.getOrDefault(&quot;page_size&quot;, &quot;A4&quot;);</span>
<span class="nc" id="L811">    String pages = (String) options.getOrDefault(&quot;pages&quot;, &quot;all&quot;);</span>

<span class="nc" id="L813">    Path resultPath = Paths.get(&quot;temp&quot;, &quot;result_&quot; + job.getId() + &quot;.pdf&quot;);</span>
<span class="nc" id="L814">    Files.createDirectories(resultPath.getParent());</span>

    // Definir dimensões baseadas no tamanho da página
<span class="nc" id="L817">    org.apache.pdfbox.pdmodel.common.PDRectangle newSize = getPageSize(pageSize);</span>

<span class="nc" id="L819">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
      List&lt;Integer&gt; pageNumbers =
<span class="nc bnc" id="L821" title="All 2 branches missed.">          pages.equals(&quot;all&quot;)</span>
<span class="nc" id="L822">              ? getAllPageNumbers(document.getNumberOfPages())</span>
<span class="nc" id="L823">              : parsePageRange(pages, document.getNumberOfPages());</span>

<span class="nc bnc" id="L825" title="All 2 branches missed.">      for (int pageNum : pageNumbers) {</span>
<span class="nc" id="L826">        PDPage page = document.getPage(pageNum - 1);</span>
<span class="nc" id="L827">        page.setMediaBox(newSize);</span>
<span class="nc" id="L828">        page.setCropBox(newSize);</span>
<span class="nc" id="L829">      }</span>

<span class="nc" id="L831">      document.save(resultPath.toFile());</span>
    }

<span class="nc" id="L834">    return resultPath.toString();</span>
  }

  private String processCompress(Job job) throws IOException {
<span class="nc" id="L838">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="nc" id="L840">      throw new IllegalArgumentException(&quot;COMPRESS operation requires at least 1 input file&quot;);</span>
    }

<span class="nc" id="L843">    String inputPath = inputFiles.get(0);</span>
<span class="nc" id="L844">    File file = new File(inputPath);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L846">      throw new IllegalArgumentException(&quot;Input file not found: &quot; + inputPath);</span>
    }

<span class="nc" id="L849">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc" id="L850">    String quality = (String) options.getOrDefault(&quot;quality&quot;, &quot;medium&quot;);</span>

<span class="nc" id="L852">    Path resultPath = Paths.get(&quot;temp&quot;, &quot;result_&quot; + job.getId() + &quot;.pdf&quot;);</span>
<span class="nc" id="L853">    Files.createDirectories(resultPath.getParent());</span>

<span class="nc" id="L855">    try (PDDocument document = Loader.loadPDF(new File(inputPath))) {</span>
      // Compressão básica - remove objetos não utilizados
<span class="nc" id="L857">      document</span>
<span class="nc" id="L858">          .getDocumentCatalog()</span>
<span class="nc" id="L859">          .getPages()</span>
<span class="nc" id="L860">          .forEach(</span>
              page -&gt; {
                try {
                  // Remove recursos não utilizados
<span class="nc bnc" id="L864" title="All 2 branches missed.">                  if (page.getResources() != null) {</span>
                    // Implementação básica de compressão
                    // Em uma implementação mais avançada, seria possível
                    // comprimir imagens e otimizar fontes
                  }
<span class="nc" id="L869">                } catch (Exception e) {</span>
                  // Log error but continue processing
<span class="nc" id="L871">                }</span>
<span class="nc" id="L872">              });</span>

<span class="nc" id="L874">      document.save(resultPath.toFile());</span>
    }

<span class="nc" id="L877">    return resultPath.toString();</span>
  }

  private String processPdfToImages(Job job) throws IOException {
<span class="nc bnc" id="L881" title="All 2 branches missed.">    if (job.getInputFiles().isEmpty()) {</span>
<span class="nc" id="L882">      throw new IllegalArgumentException(&quot;No input files provided&quot;);</span>
    }

<span class="nc" id="L885">    String inputFile = job.getInputFiles().get(0);</span>
<span class="nc" id="L886">    File file = new File(inputFile);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L888">      throw new IllegalArgumentException(&quot;Input file does not exist: &quot; + inputFile);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L892">    Path resultDir = Paths.get(&quot;results&quot;, job.getId());</span>
<span class="nc" id="L893">    Files.createDirectories(resultDir);</span>

<span class="nc" id="L895">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc" id="L896">    String format = options.getOrDefault(&quot;format&quot;, &quot;PNG&quot;).toString().toUpperCase();</span>
<span class="nc" id="L897">    float dpi = Float.parseFloat(options.getOrDefault(&quot;dpi&quot;, &quot;150&quot;).toString());</span>
<span class="nc" id="L898">    String pages = options.getOrDefault(&quot;pages&quot;, &quot;all&quot;).toString();</span>

<span class="nc" id="L900">    List&lt;String&gt; imageFiles = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L902">    try (PDDocument document = Loader.loadPDF(file)) {</span>
<span class="nc" id="L903">      PDFRenderer pdfRenderer = new PDFRenderer(document);</span>
<span class="nc" id="L904">      int totalPages = document.getNumberOfPages();</span>
      
<span class="nc" id="L906">      List&lt;Integer&gt; pagesToProcess = parsePageRange(pages, totalPages);</span>
      
<span class="nc bnc" id="L908" title="All 2 branches missed.">      for (int pageIndex : pagesToProcess) {</span>
<span class="nc" id="L909">        BufferedImage image = pdfRenderer.renderImageWithDPI(pageIndex, dpi, ImageType.RGB);</span>
        
<span class="nc" id="L911">        String imageFileName = String.format(&quot;page_%03d.%s&quot;, pageIndex + 1, format.toLowerCase());</span>
<span class="nc" id="L912">        Path imagePath = resultDir.resolve(imageFileName);</span>
        
<span class="nc" id="L914">        ImageIO.write(image, format, imagePath.toFile());</span>
<span class="nc" id="L915">        imageFiles.add(imagePath.toString());</span>
<span class="nc" id="L916">      }</span>
    }

<span class="nc" id="L919">    System.out.println(&quot;PDF converted to &quot; + imageFiles.size() + &quot; images. Results saved to: &quot; + resultDir);</span>
<span class="nc" id="L920">    return resultDir.toString();</span>
  }

  private String processImagesToPdf(Job job) throws IOException {
<span class="nc bnc" id="L924" title="All 2 branches missed.">    if (job.getInputFiles().isEmpty()) {</span>
<span class="nc" id="L925">      throw new IllegalArgumentException(&quot;No input files provided&quot;);</span>
    }

    // Criar diretório de resultado
<span class="nc" id="L929">    Path resultDir = Paths.get(&quot;results&quot;, job.getId());</span>
<span class="nc" id="L930">    Files.createDirectories(resultDir);</span>
<span class="nc" id="L931">    String resultPath = resultDir.resolve(&quot;images_to_pdf.pdf&quot;).toString();</span>

<span class="nc" id="L933">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="nc" id="L934">    String pageSize = options.getOrDefault(&quot;page_size&quot;, &quot;A4&quot;).toString();</span>
<span class="nc" id="L935">    boolean fitToPage = Boolean.parseBoolean(options.getOrDefault(&quot;fit_to_page&quot;, &quot;true&quot;).toString());</span>

<span class="nc" id="L937">    try (PDDocument document = new PDDocument()) {</span>
<span class="nc" id="L938">      PDRectangle pageRect = getPageSize(pageSize);</span>
      
<span class="nc bnc" id="L940" title="All 2 branches missed.">      for (String imageFile : job.getInputFiles()) {</span>
<span class="nc" id="L941">        File file = new File(imageFile);</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L943">          System.out.println(&quot;Warning: Image file does not exist, skipping: &quot; + imageFile);</span>
<span class="nc" id="L944">          continue;</span>
        }

        try {
<span class="nc" id="L948">          BufferedImage image = ImageIO.read(file);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">          if (image == null) {</span>
<span class="nc" id="L950">            System.out.println(&quot;Warning: Could not read image file, skipping: &quot; + imageFile);</span>
<span class="nc" id="L951">            continue;</span>
          }

<span class="nc" id="L954">          PDPage page = new PDPage(pageRect);</span>
<span class="nc" id="L955">          document.addPage(page);</span>

<span class="nc" id="L957">          PDImageXObject pdImage = PDImageXObject.createFromByteArray(</span>
<span class="nc" id="L958">              document, Files.readAllBytes(file.toPath()), file.getName());</span>

<span class="nc" id="L960">          try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (fitToPage) {</span>
              // Calcular escala para ajustar à página mantendo proporção
<span class="nc" id="L963">              float imageWidth = pdImage.getWidth();</span>
<span class="nc" id="L964">              float imageHeight = pdImage.getHeight();</span>
<span class="nc" id="L965">              float pageWidth = pageRect.getWidth();</span>
<span class="nc" id="L966">              float pageHeight = pageRect.getHeight();</span>
              
<span class="nc" id="L968">              float scaleX = pageWidth / imageWidth;</span>
<span class="nc" id="L969">              float scaleY = pageHeight / imageHeight;</span>
<span class="nc" id="L970">              float scale = Math.min(scaleX, scaleY);</span>
              
<span class="nc" id="L972">              float scaledWidth = imageWidth * scale;</span>
<span class="nc" id="L973">              float scaledHeight = imageHeight * scale;</span>
              
              // Centralizar na página
<span class="nc" id="L976">              float x = (pageWidth - scaledWidth) / 2;</span>
<span class="nc" id="L977">              float y = (pageHeight - scaledHeight) / 2;</span>
              
<span class="nc" id="L979">              contentStream.drawImage(pdImage, x, y, scaledWidth, scaledHeight);</span>
<span class="nc" id="L980">            } else {</span>
              // Usar tamanho original da imagem
<span class="nc" id="L982">              contentStream.drawImage(pdImage, 0, 0);</span>
            }
          }
<span class="nc" id="L985">        } catch (Exception e) {</span>
<span class="nc" id="L986">          System.out.println(&quot;Error processing image &quot; + imageFile + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L987">        }</span>
<span class="nc" id="L988">      }</span>

<span class="nc bnc" id="L990" title="All 2 branches missed.">      if (document.getNumberOfPages() == 0) {</span>
<span class="nc" id="L991">        throw new IllegalArgumentException(&quot;No valid images were processed&quot;);</span>
      }

<span class="nc" id="L994">      document.save(resultPath);</span>
    }

<span class="nc" id="L997">    System.out.println(&quot;Images converted to PDF. Result saved to: &quot; + resultPath);</span>
<span class="nc" id="L998">    return resultPath;</span>
  }

  private String processPdfCompare(Job job) throws IOException {
<span class="fc" id="L1002">    List&lt;String&gt; inputFiles = job.getInputFiles();</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">    if (inputFiles.size() != 2) {</span>
<span class="fc" id="L1004">      throw new IllegalArgumentException(&quot;PDF_COMPARE operation requires exactly two input files&quot;);</span>
    }

<span class="nc" id="L1007">    String inputFile1 = inputFiles.get(0);</span>
<span class="nc" id="L1008">    String inputFile2 = inputFiles.get(1);</span>
<span class="nc" id="L1009">    Map&lt;String, Object&gt; options = job.getOptions();</span>

    // Criar diretório de resultado
<span class="nc" id="L1012">    Path resultDir = Paths.get(&quot;storage&quot;, &quot;results&quot;, job.getId());</span>
<span class="nc" id="L1013">    Files.createDirectories(resultDir);</span>

<span class="nc" id="L1015">    try (PDDocument doc1 = Loader.loadPDF(new File(inputFile1));</span>
<span class="nc" id="L1016">         PDDocument doc2 = Loader.loadPDF(new File(inputFile2))) {</span>

      // Comparação básica de metadados e estrutura
<span class="nc" id="L1019">      StringBuilder comparisonReport = new StringBuilder();</span>
<span class="nc" id="L1020">      comparisonReport.append(&quot;PDF Comparison Report\n&quot;);</span>
<span class="nc" id="L1021">      comparisonReport.append(&quot;========================\n\n&quot;);</span>
      
      // Comparar número de páginas
<span class="nc" id="L1024">      int pages1 = doc1.getNumberOfPages();</span>
<span class="nc" id="L1025">      int pages2 = doc2.getNumberOfPages();</span>
<span class="nc" id="L1026">      comparisonReport.append(String.format(&quot;File 1 pages: %d\n&quot;, pages1));</span>
<span class="nc" id="L1027">      comparisonReport.append(String.format(&quot;File 2 pages: %d\n&quot;, pages2));</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">      comparisonReport.append(String.format(&quot;Pages match: %s\n\n&quot;, pages1 == pages2 ? &quot;YES&quot; : &quot;NO&quot;));</span>

      // Comparar texto de cada página
<span class="nc" id="L1031">      PDFTextStripper stripper = new PDFTextStripper();</span>
<span class="nc" id="L1032">      int maxPages = Math.max(pages1, pages2);</span>
<span class="nc" id="L1033">      int differentPages = 0;</span>
      
<span class="nc bnc" id="L1035" title="All 2 branches missed.">      for (int i = 1; i &lt;= maxPages; i++) {</span>
<span class="nc" id="L1036">        String text1 = &quot;&quot;;</span>
<span class="nc" id="L1037">        String text2 = &quot;&quot;;</span>
        
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (i &lt;= pages1) {</span>
<span class="nc" id="L1040">          stripper.setStartPage(i);</span>
<span class="nc" id="L1041">          stripper.setEndPage(i);</span>
<span class="nc" id="L1042">          text1 = stripper.getText(doc1).trim();</span>
        }
        
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if (i &lt;= pages2) {</span>
<span class="nc" id="L1046">          stripper.setStartPage(i);</span>
<span class="nc" id="L1047">          stripper.setEndPage(i);</span>
<span class="nc" id="L1048">          text2 = stripper.getText(doc2).trim();</span>
        }
        
<span class="nc" id="L1051">        boolean pageMatches = text1.equals(text2);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        if (!pageMatches) {</span>
<span class="nc" id="L1053">          differentPages++;</span>
<span class="nc" id="L1054">          comparisonReport.append(String.format(&quot;Page %d: DIFFERENT\n&quot;, i));</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">          if (Boolean.TRUE.equals(options.get(&quot;detailed_diff&quot;))) {</span>
<span class="nc" id="L1056">            comparisonReport.append(String.format(&quot;  File 1 length: %d chars\n&quot;, text1.length()));</span>
<span class="nc" id="L1057">            comparisonReport.append(String.format(&quot;  File 2 length: %d chars\n&quot;, text2.length()));</span>
          }
        }
      }
      
<span class="nc" id="L1062">      comparisonReport.append(String.format(&quot;\nSummary: %d of %d pages are different\n&quot;, differentPages, maxPages));</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">      comparisonReport.append(String.format(&quot;Files are identical: %s\n&quot;, differentPages == 0 ? &quot;YES&quot; : &quot;NO&quot;));</span>

      // Salvar relatório
<span class="nc" id="L1066">      String reportFilename = options.getOrDefault(&quot;output_filename&quot;, &quot;comparison_report.txt&quot;).toString();</span>
<span class="nc" id="L1067">      Path reportPath = resultDir.resolve(reportFilename);</span>
<span class="nc" id="L1068">      Files.write(reportPath, comparisonReport.toString().getBytes(StandardCharsets.UTF_8));</span>

<span class="nc" id="L1070">      return reportPath.toString();</span>
    }
  }

  private String processPdfCreate(Job job) throws IOException {
<span class="nc" id="L1075">    Map&lt;String, Object&gt; options = job.getOptions();</span>
    
    // Criar diretório de resultado
<span class="nc" id="L1078">    Path resultDir = Paths.get(&quot;storage&quot;, &quot;results&quot;, job.getId());</span>
<span class="nc" id="L1079">    Files.createDirectories(resultDir);</span>

<span class="nc" id="L1081">    try (PDDocument document = new PDDocument()) {</span>
      // Configurações padrão
<span class="nc" id="L1083">      String pageSize = options.getOrDefault(&quot;page_size&quot;, &quot;A4&quot;).toString();</span>
<span class="nc" id="L1084">      PDRectangle pageRect = getPageSize(pageSize);</span>
      
      // Criar páginas baseado no conteúdo
<span class="nc bnc" id="L1087" title="All 2 branches missed.">      if (options.containsKey(&quot;text_content&quot;)) {</span>
<span class="nc" id="L1088">        createPdfFromText(document, options.get(&quot;text_content&quot;).toString(), pageRect, options);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">      } else if (options.containsKey(&quot;pages&quot;)) {</span>
        // Criar páginas em branco
<span class="nc" id="L1091">        int numPages = Integer.parseInt(options.get(&quot;pages&quot;).toString());</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for (int i = 0; i &lt; numPages; i++) {</span>
<span class="nc" id="L1093">          document.addPage(new PDPage(pageRect));</span>
        }
<span class="nc" id="L1095">      } else {</span>
        // Criar uma página em branco por padrão
<span class="nc" id="L1097">        document.addPage(new PDPage(pageRect));</span>
      }

      // Adicionar metadados se fornecidos
<span class="nc bnc" id="L1101" title="All 6 branches missed.">      if (options.containsKey(&quot;title&quot;) || options.containsKey(&quot;author&quot;) || options.containsKey(&quot;subject&quot;)) {</span>
<span class="nc" id="L1102">        PDDocumentInformation info = new PDDocumentInformation();</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (options.containsKey(&quot;title&quot;)) {</span>
<span class="nc" id="L1104">          info.setTitle(options.get(&quot;title&quot;).toString());</span>
        }
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (options.containsKey(&quot;author&quot;)) {</span>
<span class="nc" id="L1107">          info.setAuthor(options.get(&quot;author&quot;).toString());</span>
        }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (options.containsKey(&quot;subject&quot;)) {</span>
<span class="nc" id="L1110">          info.setSubject(options.get(&quot;subject&quot;).toString());</span>
        }
<span class="nc" id="L1112">        document.setDocumentInformation(info);</span>
      }

      // Salvar documento
<span class="nc" id="L1116">      String outputFilename = options.getOrDefault(&quot;output_filename&quot;, &quot;created_document.pdf&quot;).toString();</span>
<span class="nc" id="L1117">      Path outputPath = resultDir.resolve(outputFilename);</span>
<span class="nc" id="L1118">      document.save(outputPath.toFile());</span>

<span class="nc" id="L1120">      return outputPath.toString();</span>
    }
  }

  private String processPdfEdit(Job job) throws IOException {
<span class="fc bfc" id="L1125" title="All 2 branches covered.">    if (job.getInputFiles().size() != 1) {</span>
<span class="fc" id="L1126">      throw new IllegalArgumentException(&quot;PDF_EDIT operation requires exactly one input file&quot;);</span>
    }
    
<span class="fc" id="L1129">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="fc" id="L1130">    String editType = (String) options.get(&quot;edit_type&quot;);</span>
    
<span class="fc bfc" id="L1132" title="All 2 branches covered.">    if (editType == null) {</span>
<span class="fc" id="L1133">      throw new IllegalArgumentException(&quot;Edit type is required (add_text, remove_text, replace_text)&quot;);</span>
    }
    
    // Validate edit type and required parameters before loading PDF
<span class="pc bpc" id="L1137" title="1 of 4 branches missed.">    switch (editType.toLowerCase()) {</span>
      case &quot;add_text&quot; -&gt; {
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">        if (options.get(&quot;text&quot;) == null) {</span>
<span class="fc" id="L1140">          throw new IllegalArgumentException(&quot;Text is required for addText operation&quot;);</span>
        }
      }
      case &quot;remove_text&quot; -&gt; {
        // No additional validation needed for remove_text
<span class="nc" id="L1145">      }</span>
      case &quot;replace_text&quot; -&gt; {
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">        if (options.get(&quot;new_text&quot;) == null) {</span>
<span class="fc" id="L1148">          throw new IllegalArgumentException(&quot;New text is required for replace_text operation&quot;);</span>
        }
      }
<span class="fc" id="L1151">      default -&gt; throw new IllegalArgumentException(&quot;Unsupported edit type: &quot; + editType + &quot;. Supported types: add_text, remove_text, replace_text&quot;);</span>
    }
    
<span class="nc" id="L1154">    Path inputPath = Paths.get(job.getInputFiles().get(0));</span>
<span class="nc" id="L1155">    Path resultDir = Paths.get(&quot;storage&quot;, &quot;results&quot;, job.getId());</span>
<span class="nc" id="L1156">    Files.createDirectories(resultDir);</span>
    
<span class="nc" id="L1158">    try (PDDocument document = Loader.loadPDF(inputPath.toFile())) {</span>
<span class="nc bnc" id="L1159" title="All 4 branches missed.">      switch (editType.toLowerCase()) {</span>
<span class="nc" id="L1160">        case &quot;add_text&quot; -&gt; addTextToDocument(document, options);</span>
<span class="nc" id="L1161">        case &quot;remove_text&quot; -&gt; removeTextFromDocument(document, options);</span>
<span class="nc" id="L1162">        case &quot;replace_text&quot; -&gt; replaceTextInDocument(document, options);</span>
      }
      
<span class="nc" id="L1165">      String outputFilename = options.getOrDefault(&quot;output_filename&quot;, &quot;edited_&quot; + inputPath.getFileName()).toString();</span>
<span class="nc" id="L1166">      Path outputPath = resultDir.resolve(outputFilename);</span>
<span class="nc" id="L1167">      document.save(outputPath.toFile());</span>
      
<span class="nc" id="L1169">      return outputPath.toString();</span>
    }
  }

  private String processPdfProtect(Job job) throws IOException {
<span class="fc bfc" id="L1174" title="All 2 branches covered.">    if (job.getInputFiles().size() != 1) {</span>
<span class="fc" id="L1175">      throw new IllegalArgumentException(&quot;PDF_PROTECT operation requires exactly one input file&quot;);</span>
    }
    
<span class="fc" id="L1178">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="fc" id="L1179">    String userPassword = (String) options.get(&quot;userPassword&quot;);</span>
<span class="fc" id="L1180">    String ownerPassword = (String) options.get(&quot;ownerPassword&quot;);</span>
    
<span class="pc bpc" id="L1182" title="2 of 4 branches missed.">    if (userPassword == null &amp;&amp; ownerPassword == null) {</span>
<span class="fc" id="L1183">      throw new IllegalArgumentException(&quot;At least one password (user or owner) is required&quot;);</span>
    }
    
<span class="nc" id="L1186">    Path inputPath = Paths.get(job.getInputFiles().get(0));</span>
<span class="nc" id="L1187">    Path resultDir = Paths.get(&quot;storage&quot;, &quot;results&quot;, job.getId());</span>
<span class="nc" id="L1188">    Files.createDirectories(resultDir);</span>
    
<span class="nc" id="L1190">    try (PDDocument document = Loader.loadPDF(inputPath.toFile())) {</span>
      // Configurar permissões
<span class="nc" id="L1192">      AccessPermission accessPermission = new AccessPermission();</span>
      
      // Aplicar restrições baseadas nas opções
<span class="nc" id="L1195">      Boolean allowPrint = (Boolean) options.getOrDefault(&quot;allowPrint&quot;, true);</span>
<span class="nc" id="L1196">      Boolean allowCopy = (Boolean) options.getOrDefault(&quot;allowCopy&quot;, true);</span>
<span class="nc" id="L1197">      Boolean allowModify = (Boolean) options.getOrDefault(&quot;allowModify&quot;, false);</span>
      
<span class="nc" id="L1199">      accessPermission.setCanPrint(allowPrint);</span>
<span class="nc" id="L1200">      accessPermission.setCanExtractContent(allowCopy);</span>
<span class="nc" id="L1201">      accessPermission.setCanModify(allowModify);</span>
      
      // Criar política de proteção
<span class="nc" id="L1204">      StandardProtectionPolicy protectionPolicy = new StandardProtectionPolicy(</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">          ownerPassword != null ? ownerPassword : userPassword,</span>
          userPassword,
          accessPermission
      );
      
<span class="nc" id="L1210">      protectionPolicy.setEncryptionKeyLength(128);</span>
<span class="nc" id="L1211">      document.protect(protectionPolicy);</span>
      
<span class="nc" id="L1213">      String outputFilename = options.getOrDefault(&quot;output_filename&quot;, &quot;protected_&quot; + inputPath.getFileName()).toString();</span>
<span class="nc" id="L1214">      Path outputPath = resultDir.resolve(outputFilename);</span>
<span class="nc" id="L1215">      document.save(outputPath.toFile());</span>
      
<span class="nc" id="L1217">      return outputPath.toString();</span>
    }
  }

  private String processPdfUnlock(Job job) throws IOException {
<span class="fc bfc" id="L1222" title="All 2 branches covered.">    if (job.getInputFiles().size() != 1) {</span>
<span class="fc" id="L1223">      throw new IllegalArgumentException(&quot;PDF_UNLOCK operation requires exactly one input file&quot;);</span>
    }
    
<span class="fc" id="L1226">    Map&lt;String, Object&gt; options = job.getOptions();</span>
<span class="fc" id="L1227">    String password = (String) options.get(&quot;password&quot;);</span>
    
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">    if (password == null) {</span>
<span class="fc" id="L1230">      throw new IllegalArgumentException(&quot;Password is required to unlock PDF&quot;);</span>
    }
    
<span class="nc" id="L1233">    Path inputPath = Paths.get(job.getInputFiles().get(0));</span>
<span class="nc" id="L1234">    Path resultDir = Paths.get(&quot;storage&quot;, &quot;results&quot;, job.getId());</span>
<span class="nc" id="L1235">    Files.createDirectories(resultDir);</span>
    
<span class="nc" id="L1237">    try (PDDocument document = Loader.loadPDF(inputPath.toFile(), password)) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">      if (document.isEncrypted()) {</span>
        // Remover proteção salvando sem criptografia
<span class="nc" id="L1240">        String outputFilename = options.getOrDefault(&quot;output_filename&quot;, &quot;unlocked_&quot; + inputPath.getFileName()).toString();</span>
<span class="nc" id="L1241">        Path outputPath = resultDir.resolve(outputFilename);</span>
<span class="nc" id="L1242">        document.save(outputPath.toFile());</span>
        
<span class="nc" id="L1244">        return outputPath.toString();</span>
      } else {
<span class="nc" id="L1246">        return &quot;PDF is not encrypted&quot;;</span>
      }
<span class="nc bnc" id="L1248" title="All 2 branches missed.">    }</span>
  }

  private void addTextToDocument(PDDocument document, Map&lt;String, Object&gt; options) throws IOException {
<span class="nc" id="L1252">    String text = (String) options.get(&quot;text&quot;);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    if (text == null) {</span>
<span class="nc" id="L1254">      throw new IllegalArgumentException(&quot;Text is required for addText operation&quot;);</span>
    }
    
<span class="nc" id="L1257">    int pageNumber = Integer.parseInt(options.getOrDefault(&quot;page&quot;, &quot;1&quot;).toString()) - 1;</span>
<span class="nc" id="L1258">    float x = Float.parseFloat(options.getOrDefault(&quot;x&quot;, &quot;50&quot;).toString());</span>
<span class="nc" id="L1259">    float y = Float.parseFloat(options.getOrDefault(&quot;y&quot;, &quot;750&quot;).toString());</span>
<span class="nc" id="L1260">    float fontSize = Float.parseFloat(options.getOrDefault(&quot;fontSize&quot;, &quot;12&quot;).toString());</span>
    
<span class="nc bnc" id="L1262" title="All 4 branches missed.">    if (pageNumber &gt;= 0 &amp;&amp; pageNumber &lt; document.getNumberOfPages()) {</span>
<span class="nc" id="L1263">      PDPage page = document.getPage(pageNumber);</span>
<span class="nc" id="L1264">      try (PDPageContentStream contentStream = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true)) {</span>
<span class="nc" id="L1265">        contentStream.beginText();</span>
<span class="nc" id="L1266">        contentStream.setFont(new PDType1Font(Standard14Fonts.FontName.HELVETICA), fontSize);</span>
<span class="nc" id="L1267">        contentStream.newLineAtOffset(x, y);</span>
<span class="nc" id="L1268">        contentStream.showText(text);</span>
<span class="nc" id="L1269">        contentStream.endText();</span>
      }
    }
<span class="nc" id="L1272">  }</span>

  private void removeTextFromDocument(PDDocument document, Map&lt;String, Object&gt; options) throws IOException {
    // Implementação básica - na prática, remover texto específico é complexo
    // Esta implementação remove todo o texto de uma página específica
<span class="nc" id="L1277">    int pageNumber = Integer.parseInt(options.getOrDefault(&quot;page&quot;, &quot;1&quot;).toString()) - 1;</span>
    
<span class="nc bnc" id="L1279" title="All 4 branches missed.">    if (pageNumber &gt;= 0 &amp;&amp; pageNumber &lt; document.getNumberOfPages()) {</span>
<span class="nc" id="L1280">      PDPage page = document.getPage(pageNumber);</span>
      // Criar uma nova página em branco com o mesmo tamanho
<span class="nc" id="L1282">      PDPage newPage = new PDPage(page.getMediaBox());</span>
<span class="nc" id="L1283">      document.removePage(pageNumber);</span>
<span class="nc" id="L1284">      document.getPages().insertBefore(newPage, document.getPage(Math.min(pageNumber, document.getNumberOfPages() - 1)));</span>
    }
<span class="nc" id="L1286">  }</span>

  private void replaceTextInDocument(PDDocument document, Map&lt;String, Object&gt; options) throws IOException {
    // Implementação básica - substitui todo o conteúdo de uma página
<span class="nc" id="L1290">    String newText = (String) options.get(&quot;new_text&quot;);</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">    if (newText == null) {</span>
<span class="nc" id="L1292">      throw new IllegalArgumentException(&quot;New text is required for replace_text operation&quot;);</span>
    }
    
<span class="nc" id="L1295">    int pageNumber = Integer.parseInt(options.getOrDefault(&quot;page&quot;, &quot;1&quot;).toString()) - 1;</span>
    
<span class="nc bnc" id="L1297" title="All 4 branches missed.">    if (pageNumber &gt;= 0 &amp;&amp; pageNumber &lt; document.getNumberOfPages()) {</span>
<span class="nc" id="L1298">      PDPage page = document.getPage(pageNumber);</span>
<span class="nc" id="L1299">      PDRectangle pageSize = page.getMediaBox();</span>
      
      // Remover página existente e criar nova
<span class="nc" id="L1302">      document.removePage(pageNumber);</span>
<span class="nc" id="L1303">      PDPage newPage = new PDPage(pageSize);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">      document.getPages().insertBefore(newPage, pageNumber &lt; document.getNumberOfPages() ? document.getPage(pageNumber) : null);</span>
      
      // Adicionar novo texto
<span class="nc" id="L1307">      try (PDPageContentStream contentStream = new PDPageContentStream(document, newPage)) {</span>
<span class="nc" id="L1308">        contentStream.beginText();</span>
<span class="nc" id="L1309">        contentStream.setFont(new PDType1Font(Standard14Fonts.FontName.HELVETICA), 12);</span>
<span class="nc" id="L1310">        contentStream.newLineAtOffset(50, pageSize.getHeight() - 50);</span>
<span class="nc" id="L1311">        contentStream.showText(newText);</span>
<span class="nc" id="L1312">        contentStream.endText();</span>
      }
    }
<span class="nc" id="L1315">  }</span>

  private void createPdfFromText(PDDocument document, String text, PDRectangle pageRect, Map&lt;String, Object&gt; options) throws IOException {
<span class="nc" id="L1318">    PDPage page = new PDPage(pageRect);</span>
<span class="nc" id="L1319">    document.addPage(page);</span>

<span class="nc" id="L1321">    try (PDPageContentStream contentStream = new PDPageContentStream(document, page)) {</span>
      // Configurações de texto
<span class="nc" id="L1323">      float fontSize = Float.parseFloat(options.getOrDefault(&quot;font_size&quot;, &quot;12&quot;).toString());</span>
<span class="nc" id="L1324">      float margin = Float.parseFloat(options.getOrDefault(&quot;margin&quot;, &quot;50&quot;).toString());</span>
<span class="nc" id="L1325">      float leading = fontSize * 1.2f;</span>
      
<span class="nc" id="L1327">      contentStream.beginText();</span>
<span class="nc" id="L1328">      contentStream.setFont(new PDType1Font(Standard14Fonts.FontName.HELVETICA), fontSize);</span>
<span class="nc" id="L1329">      contentStream.newLineAtOffset(margin, pageRect.getHeight() - margin);</span>

      // Quebrar texto em linhas
<span class="nc" id="L1332">      String[] lines = text.split(&quot;\n&quot;);</span>
<span class="nc" id="L1333">      float maxWidth = pageRect.getWidth() - (2 * margin);</span>
      
<span class="nc bnc" id="L1335" title="All 2 branches missed.">      for (String line : lines) {</span>
        // Verificar se a linha cabe na largura da página
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (line.length() * fontSize * 0.6f &gt; maxWidth) {</span>
          // Quebrar linha longa em múltiplas linhas
<span class="nc" id="L1339">          String[] words = line.split(&quot; &quot;);</span>
<span class="nc" id="L1340">          StringBuilder currentLine = new StringBuilder();</span>
          
<span class="nc bnc" id="L1342" title="All 2 branches missed.">          for (String word : words) {</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            String testLine = currentLine.length() &gt; 0 ? currentLine + &quot; &quot; + word : word;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">            if (testLine.length() * fontSize * 0.6f &lt;= maxWidth) {</span>
<span class="nc" id="L1345">              currentLine = new StringBuilder(testLine);</span>
            } else {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">              if (currentLine.length() &gt; 0) {</span>
<span class="nc" id="L1348">                contentStream.showText(currentLine.toString());</span>
<span class="nc" id="L1349">                contentStream.newLineAtOffset(0, -leading);</span>
              }
<span class="nc" id="L1351">              currentLine = new StringBuilder(word);</span>
            }
          }
          
<span class="nc bnc" id="L1355" title="All 2 branches missed.">          if (currentLine.length() &gt; 0) {</span>
<span class="nc" id="L1356">            contentStream.showText(currentLine.toString());</span>
<span class="nc" id="L1357">            contentStream.newLineAtOffset(0, -leading);</span>
          }
<span class="nc" id="L1359">        } else {</span>
<span class="nc" id="L1360">          contentStream.showText(line);</span>
<span class="nc" id="L1361">          contentStream.newLineAtOffset(0, -leading);</span>
        }
      }
      
<span class="nc" id="L1365">      contentStream.endText();</span>
    }
<span class="nc" id="L1367">  }</span>

  // Métodos auxiliares para operações avançadas

  private List&lt;Integer&gt; getAllPageNumbers(int totalPages) {
<span class="nc" id="L1372">    List&lt;Integer&gt; pages = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">    for (int i = 1; i &lt;= totalPages; i++) {</span>
<span class="nc" id="L1374">      pages.add(i);</span>
    }
<span class="nc" id="L1376">    return pages;</span>
  }

  private org.apache.pdfbox.pdmodel.common.PDRectangle getPageSize(String pageSize) {
<span class="nc bnc" id="L1380" title="All 6 branches missed.">    return switch (pageSize.toUpperCase()) {</span>
<span class="nc" id="L1381">      case &quot;A4&quot; -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.A4;</span>
<span class="nc" id="L1382">      case &quot;A3&quot; -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.A3;</span>
<span class="nc" id="L1383">      case &quot;A5&quot; -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.A5;</span>
<span class="nc" id="L1384">      case &quot;LETTER&quot; -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.LETTER;</span>
<span class="nc" id="L1385">      case &quot;LEGAL&quot; -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.LEGAL;</span>
<span class="nc" id="L1386">      default -&gt; org.apache.pdfbox.pdmodel.common.PDRectangle.A4;</span>
    };
  }

  @Override
  public boolean supportsOperation(JobOperation operation) {
<span class="fc" id="L1392">    return SUPPORTED_OPERATIONS.contains(operation);</span>
  }

  @Override
  public List&lt;JobOperation&gt; getSupportedOperations() {
<span class="fc" id="L1397">    return List.copyOf(SUPPORTED_OPERATIONS);</span>
  }

  @Override
  public boolean validateOptions(JobOperation operation, Map&lt;String, Object&gt; options) {
<span class="fc" id="L1402">    System.out.println(</span>
        &quot;DEBUG: validateOptions called with operation: &quot; + operation + &quot;, options: &quot; + options);

<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L1406">      System.out.println(&quot;DEBUG: options is null, returning false&quot;);</span>
<span class="nc" id="L1407">      return false;</span>
    }

    try {
<span class="fc" id="L1411">      boolean result =</span>
<span class="pc bpc" id="L1412" title="3 of 13 branches missed.">          switch (operation) {</span>
<span class="nc" id="L1413">            case PDF_REORDER -&gt; options.containsKey(&quot;page_order&quot;);</span>
<span class="nc" id="L1414">            case PDF_CROP -&gt; validateCropOptions(options);</span>
<span class="nc" id="L1415">            case PDF_RESIZE -&gt; validateResizeOptions(options);</span>
<span class="fc" id="L1416">            case ROTATE -&gt; validateRotateOptions(options);</span>
<span class="fc" id="L1417">            case ENCRYPT -&gt; options.containsKey(&quot;password&quot;);</span>
<span class="fc" id="L1418">            case DECRYPT -&gt; options.containsKey(&quot;password&quot;);</span>
<span class="fc" id="L1419">            case WATERMARK -&gt; options.containsKey(&quot;text&quot;);</span>
<span class="fc" id="L1420">            case PDF_TO_IMAGES -&gt; validatePdfToImagesOptions(options);</span>
<span class="fc" id="L1421">            case IMAGES_TO_PDF -&gt; validateImagesToPdfOptions(options);</span>
<span class="fc" id="L1422">            case PDF_EDIT -&gt; validatePdfEditOptions(options);</span>
<span class="fc" id="L1423">            case PDF_PROTECT -&gt; validatePdfProtectOptions(options);</span>
<span class="fc" id="L1424">            case PDF_UNLOCK -&gt; options.containsKey(&quot;password&quot;);</span>
<span class="fc" id="L1425">            default -&gt; true;</span>
          };
<span class="fc" id="L1427">      System.out.println(&quot;DEBUG: validateOptions result: &quot; + result);</span>
<span class="fc" id="L1428">      return result;</span>
<span class="nc" id="L1429">    } catch (Exception e) {</span>
<span class="nc" id="L1430">      System.out.println(&quot;DEBUG: Exception in validateOptions: &quot; + e.getMessage());</span>
<span class="nc" id="L1431">      e.printStackTrace();</span>
<span class="nc" id="L1432">      return false;</span>
    }
  }

  private boolean validateCropOptions(Map&lt;String, Object&gt; options) {
    try {
<span class="nc bnc" id="L1438" title="All 2 branches missed.">      if (options.containsKey(&quot;x&quot;)) ((Number) options.get(&quot;x&quot;)).floatValue();</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">      if (options.containsKey(&quot;y&quot;)) ((Number) options.get(&quot;y&quot;)).floatValue();</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">      if (options.containsKey(&quot;width&quot;)) ((Number) options.get(&quot;width&quot;)).floatValue();</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">      if (options.containsKey(&quot;height&quot;)) ((Number) options.get(&quot;height&quot;)).floatValue();</span>
<span class="nc" id="L1442">      return true;</span>
<span class="nc" id="L1443">    } catch (Exception e) {</span>
<span class="nc" id="L1444">      return false;</span>
    }
  }

  private boolean validateResizeOptions(Map&lt;String, Object&gt; options) {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">    if (options.containsKey(&quot;page_size&quot;)) {</span>
<span class="nc" id="L1450">      String pageSize = (String) options.get(&quot;page_size&quot;);</span>
<span class="nc" id="L1451">      return List.of(&quot;A4&quot;, &quot;A3&quot;, &quot;A5&quot;, &quot;LETTER&quot;, &quot;LEGAL&quot;).contains(pageSize.toUpperCase());</span>
    }
<span class="nc" id="L1453">    return true;</span>
  }

  private boolean validateRotateOptions(Map&lt;String, Object&gt; options) {
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">    if (!options.containsKey(&quot;degrees&quot;)) {</span>
<span class="nc" id="L1458">      return false;</span>
    }
    
    try {
<span class="fc" id="L1462">      int degrees = Integer.parseInt(options.get(&quot;degrees&quot;).toString());</span>
<span class="pc bpc" id="L1463" title="2 of 6 branches missed.">      return degrees == 90 || degrees == 180 || degrees == 270;</span>
<span class="nc" id="L1464">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L1465">      return false;</span>
    }
  }

  private boolean validatePdfToImagesOptions(Map&lt;String, Object&gt; options) {
    try {
<span class="fc bfc" id="L1471" title="All 2 branches covered.">      if (options.containsKey(&quot;format&quot;)) {</span>
<span class="fc" id="L1472">        String format = options.get(&quot;format&quot;).toString().toUpperCase();</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">        if (!List.of(&quot;PNG&quot;, &quot;JPG&quot;, &quot;JPEG&quot;, &quot;GIF&quot;, &quot;BMP&quot;).contains(format)) {</span>
<span class="fc" id="L1474">          return false;</span>
        }
      }
<span class="fc bfc" id="L1477" title="All 2 branches covered.">      if (options.containsKey(&quot;dpi&quot;)) {</span>
<span class="fc" id="L1478">        Float.parseFloat(options.get(&quot;dpi&quot;).toString());</span>
      }
<span class="fc" id="L1480">      return true;</span>
<span class="fc" id="L1481">    } catch (Exception e) {</span>
<span class="fc" id="L1482">      return false;</span>
    }
  }

  private boolean validateImagesToPdfOptions(Map&lt;String, Object&gt; options) {
    try {
<span class="fc bfc" id="L1488" title="All 2 branches covered.">      if (options.containsKey(&quot;page_size&quot;)) {</span>
<span class="fc" id="L1489">        String pageSize = options.get(&quot;page_size&quot;).toString().toUpperCase();</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        if (!List.of(&quot;A4&quot;, &quot;A3&quot;, &quot;A5&quot;, &quot;LETTER&quot;, &quot;LEGAL&quot;).contains(pageSize)) {</span>
<span class="fc" id="L1491">          return false;</span>
        }
      }
<span class="fc bfc" id="L1494" title="All 2 branches covered.">      if (options.containsKey(&quot;fit_to_page&quot;)) {</span>
<span class="fc" id="L1495">        Boolean.parseBoolean(options.get(&quot;fit_to_page&quot;).toString());</span>
      }
<span class="fc" id="L1497">      return true;</span>
<span class="nc" id="L1498">    } catch (Exception e) {</span>
<span class="nc" id="L1499">      return false;</span>
    }
  }

  private boolean validatePdfEditOptions(Map&lt;String, Object&gt; options) {
    try {
<span class="fc bfc" id="L1505" title="All 2 branches covered.">      if (!options.containsKey(&quot;edit_type&quot;)) {</span>
<span class="fc" id="L1506">        return false;</span>
      }
<span class="fc" id="L1508">      String editType = (String) options.get(&quot;edit_type&quot;);</span>
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">      if (!List.of(&quot;add_text&quot;, &quot;remove_text&quot;, &quot;replace_text&quot;).contains(editType)) {</span>
<span class="nc" id="L1510">        return false;</span>
      }
      
      // Validação específica por tipo de edição
<span class="pc bpc" id="L1514" title="3 of 4 branches missed.">      switch (editType) {</span>
        case &quot;add_text&quot; -&gt; {
<span class="pc bpc" id="L1516" title="3 of 6 branches missed.">          return options.containsKey(&quot;text&quot;) &amp;&amp; options.containsKey(&quot;x&quot;) &amp;&amp; options.containsKey(&quot;y&quot;);</span>
        }
        case &quot;remove_text&quot; -&gt; {
<span class="nc" id="L1519">          return options.containsKey(&quot;text_to_remove&quot;);</span>
        }
        case &quot;replace_text&quot; -&gt; {
<span class="nc bnc" id="L1522" title="All 4 branches missed.">          return options.containsKey(&quot;old_text&quot;) &amp;&amp; options.containsKey(&quot;new_text&quot;);</span>
        }
      }
<span class="nc" id="L1525">      return true;</span>
<span class="nc" id="L1526">    } catch (Exception e) {</span>
<span class="nc" id="L1527">      return false;</span>
    }
  }

  private boolean validatePdfProtectOptions(Map&lt;String, Object&gt; options) {
    try {
<span class="fc bfc" id="L1533" title="All 2 branches covered.">      if (!options.containsKey(&quot;password&quot;)) {</span>
<span class="fc" id="L1534">        return false;</span>
      }
      
      // Validação de permissões opcionais
<span class="fc bfc" id="L1538" title="All 2 branches covered.">      if (options.containsKey(&quot;allow_printing&quot;)) {</span>
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">        if (!(options.get(&quot;allow_printing&quot;) instanceof Boolean)) {</span>
<span class="nc" id="L1540">          return false;</span>
        }
      }
<span class="fc bfc" id="L1543" title="All 2 branches covered.">      if (options.containsKey(&quot;allow_copying&quot;)) {</span>
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">        if (!(options.get(&quot;allow_copying&quot;) instanceof Boolean)) {</span>
<span class="nc" id="L1545">          return false;</span>
        }
      }
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">      if (options.containsKey(&quot;allow_modification&quot;)) {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">        if (!(options.get(&quot;allow_modification&quot;) instanceof Boolean)) {</span>
<span class="nc" id="L1550">          return false;</span>
        }
      }
      
<span class="fc" id="L1554">      return true;</span>
<span class="nc" id="L1555">    } catch (Exception e) {</span>
<span class="nc" id="L1556">      return false;</span>
    }
  }

  @Override
  public Map&lt;String, Object&gt; getOptionsSchema(JobOperation operation) {
<span class="fc" id="L1562">    Map&lt;String, Object&gt; baseSchema = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L1564" title="9 of 16 branches missed.">    return switch (operation) {</span>
      case PDF_CROP -&gt; {
<span class="nc" id="L1566">        baseSchema.put(&quot;x&quot;, &quot;number (optional, default: 0)&quot;);</span>
<span class="nc" id="L1567">        baseSchema.put(&quot;y&quot;, &quot;number (optional, default: 0)&quot;);</span>
<span class="nc" id="L1568">        baseSchema.put(&quot;width&quot;, &quot;number (optional, default: 595)&quot;);</span>
<span class="nc" id="L1569">        baseSchema.put(&quot;height&quot;, &quot;number (optional, default: 842)&quot;);</span>
<span class="nc" id="L1570">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="nc" id="L1571">        yield baseSchema;</span>
      }
      case PDF_REORDER -&gt; {
<span class="nc" id="L1574">        baseSchema.put(&quot;page_order&quot;, &quot;string (required, ex: '3,1,2,4')&quot;);</span>
<span class="nc" id="L1575">        yield baseSchema;</span>
      }
      case PDF_RESIZE -&gt; {
<span class="nc" id="L1578">        baseSchema.put(</span>
            &quot;page_size&quot;, &quot;string (optional, default: 'A4', options: A4, A3, A5, LETTER, LEGAL)&quot;);
<span class="nc" id="L1580">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="nc" id="L1581">        yield baseSchema;</span>
      }
      case COMPRESS -&gt; {
<span class="nc" id="L1584">        baseSchema.put(</span>
            &quot;quality&quot;, &quot;string (optional, default: 'medium', options: low, medium, high)&quot;);
<span class="nc" id="L1586">        yield baseSchema;</span>
      }
      case ENCRYPT -&gt; {
<span class="fc" id="L1589">        baseSchema.put(&quot;password&quot;, &quot;string (required)&quot;);</span>
<span class="fc" id="L1590">        baseSchema.put(&quot;ownerPassword&quot;, &quot;string (optional)&quot;);</span>
<span class="fc" id="L1591">        baseSchema.put(&quot;allowPrint&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="fc" id="L1592">        baseSchema.put(&quot;allowCopy&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="fc" id="L1593">        baseSchema.put(&quot;allowModify&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="fc" id="L1594">        yield baseSchema;</span>
      }
      case DECRYPT -&gt; {
<span class="nc" id="L1597">        baseSchema.put(&quot;password&quot;, &quot;string (required)&quot;);</span>
<span class="nc" id="L1598">        yield baseSchema;</span>
      }
      case WATERMARK -&gt; {
<span class="fc" id="L1601">        baseSchema.put(&quot;text&quot;, &quot;string (required)&quot;);</span>
<span class="fc" id="L1602">        baseSchema.put(&quot;opacity&quot;, &quot;number (optional, default: 0.3)&quot;);</span>
<span class="fc" id="L1603">        baseSchema.put(&quot;fontSize&quot;, &quot;number (optional, default: 36)&quot;);</span>
<span class="fc" id="L1604">        baseSchema.put(</span>
            &quot;position&quot;,
            &quot;string (optional, default: 'center', options: center, top-left, top-right, bottom-left, bottom-right)&quot;);
<span class="fc" id="L1607">        yield baseSchema;</span>
      }
      case ROTATE -&gt; {
<span class="fc" id="L1610">        baseSchema.put(&quot;degrees&quot;, &quot;number (required, options: 90, 180, 270)&quot;);</span>
<span class="fc" id="L1611">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="fc" id="L1612">        yield baseSchema;</span>
      }
      case SPLIT -&gt; {
<span class="fc" id="L1615">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="fc" id="L1616">        yield baseSchema;</span>
      }
      case EXTRACT_TEXT -&gt; {
<span class="nc" id="L1619">        baseSchema.put(&quot;startPage&quot;, &quot;number (optional)&quot;);</span>
<span class="nc" id="L1620">        baseSchema.put(&quot;endPage&quot;, &quot;number (optional)&quot;);</span>
<span class="nc" id="L1621">        baseSchema.put(&quot;sortByPosition&quot;, &quot;boolean (optional, default: false)&quot;);</span>
<span class="nc" id="L1622">        yield baseSchema;</span>
      }
      case PDF_TO_IMAGES -&gt; {
<span class="fc" id="L1625">        baseSchema.put(&quot;format&quot;, &quot;string (optional, default: 'PNG', options: PNG, JPG, JPEG, GIF, BMP)&quot;);</span>
<span class="fc" id="L1626">        baseSchema.put(&quot;dpi&quot;, &quot;number (optional, default: 150)&quot;);</span>
<span class="fc" id="L1627">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="fc" id="L1628">        yield baseSchema;</span>
      }
      case IMAGES_TO_PDF -&gt; {
<span class="fc" id="L1631">        baseSchema.put(&quot;page_size&quot;, &quot;string (optional, default: 'A4', options: A4, A3, A5, LETTER, LEGAL)&quot;);</span>
<span class="fc" id="L1632">        baseSchema.put(&quot;fit_to_page&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="fc" id="L1633">        yield baseSchema;</span>
      }
      case PDF_EDIT -&gt; {
<span class="nc" id="L1636">        baseSchema.put(&quot;edit_type&quot;, &quot;string (required, options: add_text, remove_text, replace_text)&quot;);</span>
<span class="nc" id="L1637">        baseSchema.put(&quot;text&quot;, &quot;string (required for add_text)&quot;);</span>
<span class="nc" id="L1638">        baseSchema.put(&quot;x&quot;, &quot;number (required for add_text)&quot;);</span>
<span class="nc" id="L1639">        baseSchema.put(&quot;y&quot;, &quot;number (required for add_text)&quot;);</span>
<span class="nc" id="L1640">        baseSchema.put(&quot;text_to_remove&quot;, &quot;string (required for remove_text)&quot;);</span>
<span class="nc" id="L1641">        baseSchema.put(&quot;old_text&quot;, &quot;string (required for replace_text)&quot;);</span>
<span class="nc" id="L1642">        baseSchema.put(&quot;new_text&quot;, &quot;string (required for replace_text)&quot;);</span>
<span class="nc" id="L1643">        baseSchema.put(&quot;font_size&quot;, &quot;number (optional, default: 12)&quot;);</span>
<span class="nc" id="L1644">        baseSchema.put(&quot;pages&quot;, &quot;string (optional, default: 'all')&quot;);</span>
<span class="nc" id="L1645">        yield baseSchema;</span>
      }
      case PDF_PROTECT -&gt; {
<span class="nc" id="L1648">        baseSchema.put(&quot;password&quot;, &quot;string (required)&quot;);</span>
<span class="nc" id="L1649">        baseSchema.put(&quot;allow_printing&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="nc" id="L1650">        baseSchema.put(&quot;allow_copying&quot;, &quot;boolean (optional, default: true)&quot;);</span>
<span class="nc" id="L1651">        baseSchema.put(&quot;allow_modification&quot;, &quot;boolean (optional, default: false)&quot;);</span>
<span class="nc" id="L1652">        yield baseSchema;</span>
      }
      case PDF_UNLOCK -&gt; {
<span class="nc" id="L1655">        baseSchema.put(&quot;password&quot;, &quot;string (required)&quot;);</span>
<span class="nc" id="L1656">        yield baseSchema;</span>
      }
<span class="fc" id="L1658">      default -&gt; baseSchema;</span>
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>