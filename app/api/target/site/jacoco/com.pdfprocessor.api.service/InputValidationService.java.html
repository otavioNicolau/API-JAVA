<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InputValidationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PDF Processor API</a> &gt; <a href="index.source.html" class="el_package">com.pdfprocessor.api.service</a> &gt; <span class="el_source">InputValidationService.java</span></div><h1>InputValidationService.java</h1><pre class="source lang-java linenums">package com.pdfprocessor.api.service;

import com.pdfprocessor.api.exception.SecurityValidationException;
import com.pdfprocessor.domain.model.JobOperation;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

/**
 * Serviço para validação rigorosa de parâmetros de entrada.
 * Implementa validações de segurança para prevenir ataques e garantir integridade dos dados.
 */
@Service
<span class="fc" id="L16">public class InputValidationService {</span>

  // Constantes de validação
  private static final int MAX_FILENAME_LENGTH = 255;
  private static final int MAX_OPERATION_NAME_LENGTH = 50;
  private static final int MAX_OPTIONS_JSON_LENGTH = 10000;
  private static final int MAX_INPUT_FILES_COUNT = 10;
  private static final long MAX_FILE_SIZE_BYTES = 50L * 1024 * 1024; // 50MB
  
  // Padrões de validação
<span class="fc" id="L26">  private static final Pattern SAFE_FILENAME_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9._-]+$&quot;);</span>
<span class="fc" id="L27">  private static final Pattern SAFE_PATH_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9/._-]+$&quot;);</span>
<span class="fc" id="L28">  private static final Pattern UUID_PATTERN = Pattern.compile(</span>
      &quot;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$&quot;);
  
  // Lista de extensões permitidas
<span class="fc" id="L32">  private static final List&lt;String&gt; ALLOWED_FILE_EXTENSIONS = List.of(</span>
      &quot;.pdf&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.tiff&quot;, &quot;.tif&quot;);
  
  // Lista de tipos MIME permitidos
<span class="fc" id="L36">  private static final List&lt;String&gt; ALLOWED_MIME_TYPES = List.of(</span>
      &quot;application/pdf&quot;,
      &quot;image/jpeg&quot;,
      &quot;image/png&quot;,
      &quot;image/gif&quot;,
      &quot;image/bmp&quot;,
      &quot;image/tiff&quot;);

  /**
   * Valida a operação fornecida.
   *
   * @param operation nome da operação
   * @throws SecurityValidationException se a operação for inválida
   */
  public void validateOperation(String operation) {
<span class="fc bfc" id="L51" title="All 4 branches covered.">    if (operation == null || operation.trim().isEmpty()) {</span>
<span class="fc" id="L52">      throw new SecurityValidationException(</span>
          &quot;Operation parameter is required&quot;, &quot;MISSING_OPERATION&quot;);
    }
    
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    if (operation.length() &gt; MAX_OPERATION_NAME_LENGTH) {</span>
<span class="nc" id="L57">      throw new SecurityValidationException(</span>
<span class="nc" id="L58">          String.format(&quot;Operation name too long. Maximum %d characters allowed&quot;, </span>
<span class="nc" id="L59">              MAX_OPERATION_NAME_LENGTH), &quot;OPERATION_NAME_TOO_LONG&quot;);</span>
    }
    
    // Verificar se contém apenas caracteres alfanuméricos e underscore
<span class="fc bfc" id="L63" title="All 2 branches covered.">    if (!operation.matches(&quot;^[A-Z_]+$&quot;)) {</span>
<span class="fc" id="L64">      throw new SecurityValidationException(</span>
          &quot;Operation name contains invalid characters. Only uppercase letters and underscores allowed&quot;, 
          &quot;INVALID_OPERATION_FORMAT&quot;);
    }
    
    // Verificar se a operação existe no enum
    try {
<span class="fc" id="L71">      JobOperation.valueOf(operation.toUpperCase());</span>
<span class="fc" id="L72">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L73">      throw new SecurityValidationException(</span>
          &quot;Unsupported operation: &quot; + operation, &quot;UNSUPPORTED_OPERATION&quot;);
<span class="fc" id="L75">    }</span>
<span class="fc" id="L76">  }</span>

  /**
   * Valida arquivos enviados via upload.
   *
   * @param files lista de arquivos
   * @throws SecurityValidationException se algum arquivo for inválido
   */
  public void validateUploadedFiles(List&lt;MultipartFile&gt; files) {
<span class="pc bpc" id="L85" title="1 of 4 branches missed.">    if (files == null || files.isEmpty()) {</span>
<span class="fc" id="L86">      return; // Pode ser válido se inputFiles for fornecido</span>
    }
    
<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (files.size() &gt; MAX_INPUT_FILES_COUNT) {</span>
<span class="fc" id="L90">      throw new SecurityValidationException(</span>
<span class="fc" id="L91">          String.format(&quot;Maximum %d files allowed per job, but %d files provided&quot;, </span>
<span class="fc" id="L92">              MAX_INPUT_FILES_COUNT, files.size()),</span>
          &quot;MAX_FILES_EXCEEDED&quot;);
    }
    
<span class="fc bfc" id="L96" title="All 2 branches covered.">    for (MultipartFile file : files) {</span>
<span class="fc" id="L97">      validateSingleFile(file);</span>
<span class="fc" id="L98">    }</span>
<span class="fc" id="L99">  }</span>

  /**
   * Valida um único arquivo enviado.
   *
   * @param file arquivo a ser validado
   * @throws SecurityValidationException se o arquivo for inválido
   */
  private void validateSingleFile(MultipartFile file) {
<span class="pc bpc" id="L108" title="1 of 4 branches missed.">    if (file == null || file.isEmpty()) {</span>
<span class="fc" id="L109">      throw new SecurityValidationException(</span>
          &quot;Empty file not allowed&quot;, &quot;EMPTY_FILE&quot;);
    }
    
    // Validar tamanho do arquivo
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (file.getSize() &gt; MAX_FILE_SIZE_BYTES) {</span>
<span class="fc" id="L115">      throw new SecurityValidationException(</span>
<span class="fc" id="L116">          String.format(&quot;File '%s' exceeds maximum size of %d MB. File size: %.2f MB&quot;,</span>
<span class="fc" id="L117">              file.getOriginalFilename(),</span>
<span class="fc" id="L118">              MAX_FILE_SIZE_BYTES / (1024 * 1024),</span>
<span class="fc" id="L119">              file.getSize() / (1024.0 * 1024.0)),</span>
          &quot;FILE_SIZE_EXCEEDED&quot;);
    }
    
    // Validar nome do arquivo
<span class="fc" id="L124">    String filename = file.getOriginalFilename();</span>
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">    if (filename == null || filename.trim().isEmpty()) {</span>
<span class="nc" id="L126">      throw new SecurityValidationException(</span>
          &quot;Filename is required&quot;, &quot;MISSING_FILENAME&quot;);
    }
    
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">    if (filename.length() &gt; MAX_FILENAME_LENGTH) {</span>
<span class="nc" id="L131">      throw new SecurityValidationException(</span>
<span class="nc" id="L132">          String.format(&quot;Filename too long. Maximum %d characters allowed&quot;, </span>
<span class="nc" id="L133">              MAX_FILENAME_LENGTH), &quot;FILENAME_TOO_LONG&quot;);</span>
    }
    
    // Validar caracteres do nome do arquivo
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">    if (!SAFE_FILENAME_PATTERN.matcher(filename).matches()) {</span>
<span class="nc" id="L138">      throw new SecurityValidationException(</span>
          &quot;Filename contains invalid characters. Only alphanumeric, dots, hyphens and underscores allowed&quot;, 
          &quot;INVALID_FILENAME_FORMAT&quot;);
    }
    
    // Validar extensão do arquivo
<span class="fc" id="L144">    String extension = getFileExtension(filename).toLowerCase();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (!ALLOWED_FILE_EXTENSIONS.contains(extension)) {</span>
<span class="fc" id="L146">      throw new SecurityValidationException(</span>
<span class="fc" id="L147">          String.format(&quot;File extension '%s' not allowed. Allowed extensions: %s&quot;, </span>
<span class="fc" id="L148">              extension, String.join(&quot;, &quot;, ALLOWED_FILE_EXTENSIONS)), </span>
          &quot;INVALID_FILE_EXTENSION&quot;);
    }
    
    // Validar tipo MIME
<span class="fc" id="L153">    String contentType = file.getContentType();</span>
<span class="pc bpc" id="L154" title="2 of 4 branches missed.">    if (contentType != null &amp;&amp; !ALLOWED_MIME_TYPES.contains(contentType)) {</span>
<span class="nc" id="L155">      throw new SecurityValidationException(</span>
<span class="nc" id="L156">          String.format(&quot;Content type '%s' not allowed. Allowed types: %s&quot;, </span>
<span class="nc" id="L157">              contentType, String.join(&quot;, &quot;, ALLOWED_MIME_TYPES)), </span>
          &quot;INVALID_CONTENT_TYPE&quot;);
    }
<span class="fc" id="L160">  }</span>

  /**
   * Valida lista de arquivos existentes.
   *
   * @param inputFiles lista de caminhos de arquivos
   * @throws SecurityValidationException se algum caminho for inválido
   */
  public void validateInputFiles(List&lt;String&gt; inputFiles) {
<span class="pc bpc" id="L169" title="1 of 4 branches missed.">    if (inputFiles == null || inputFiles.isEmpty()) {</span>
<span class="fc" id="L170">      return; // Pode ser válido se files for fornecido</span>
    }
    
<span class="fc bfc" id="L173" title="All 2 branches covered.">    if (inputFiles.size() &gt; MAX_INPUT_FILES_COUNT) {</span>
<span class="fc" id="L174">      throw new SecurityValidationException(</span>
<span class="fc" id="L175">          String.format(&quot;Maximum %d files allowed per job, but %d files provided&quot;, </span>
<span class="fc" id="L176">              MAX_INPUT_FILES_COUNT, inputFiles.size()),</span>
          &quot;MAX_FILES_EXCEEDED&quot;);
    }
    
<span class="fc bfc" id="L180" title="All 2 branches covered.">    for (String filePath : inputFiles) {</span>
<span class="fc" id="L181">      validateInputFilePath(filePath);</span>
<span class="fc" id="L182">    }</span>
<span class="fc" id="L183">  }</span>

  /**
   * Valida um caminho de arquivo de entrada.
   *
   * @param filePath caminho do arquivo
   * @throws SecurityValidationException se o caminho for inválido
   */
  private void validateInputFilePath(String filePath) {
<span class="pc bpc" id="L192" title="2 of 4 branches missed.">    if (filePath == null || filePath.trim().isEmpty()) {</span>
<span class="nc" id="L193">      throw new SecurityValidationException(</span>
          &quot;File path cannot be empty&quot;, &quot;EMPTY_FILE_PATH&quot;);
    }
    
    // Prevenir path traversal attacks
<span class="pc bpc" id="L198" title="2 of 6 branches missed.">    if (filePath.contains(&quot;..&quot;) || filePath.contains(&quot;~&quot;) || filePath.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L199">      throw new SecurityValidationException(</span>
          &quot;Invalid file path. Path traversal not allowed&quot;, &quot;PATH_TRAVERSAL_DETECTED&quot;);
    }
    
    // Validar formato do caminho
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!SAFE_PATH_PATTERN.matcher(filePath).matches()) {</span>
<span class="nc" id="L205">      throw new SecurityValidationException(</span>
          &quot;File path contains invalid characters&quot;, &quot;INVALID_PATH_FORMAT&quot;);
    }
    
    // Validar extensão do arquivo no caminho
<span class="fc" id="L210">    String extension = getFileExtension(filePath).toLowerCase();</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">    if (!ALLOWED_FILE_EXTENSIONS.contains(extension)) {</span>
<span class="nc" id="L212">      throw new SecurityValidationException(</span>
<span class="nc" id="L213">          String.format(&quot;File extension '%s' not allowed in path '%s'&quot;, </span>
              extension, filePath), 
          &quot;INVALID_FILE_EXTENSION&quot;);
    }
<span class="fc" id="L217">  }</span>

  /**
   * Valida o JSON de opções.
   *
   * @param optionsJson string JSON com opções
   * @throws SecurityValidationException se o JSON for inválido
   */
  public void validateOptionsJson(String optionsJson) {
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">    if (optionsJson == null || optionsJson.trim().isEmpty()) {</span>
<span class="fc" id="L227">      return; // Opções são opcionais</span>
    }
    
<span class="fc bfc" id="L230" title="All 2 branches covered.">    if (optionsJson.length() &gt; MAX_OPTIONS_JSON_LENGTH) {</span>
<span class="fc" id="L231">      throw new SecurityValidationException(</span>
<span class="fc" id="L232">          String.format(&quot;Options JSON too long. Maximum %d characters allowed&quot;, </span>
<span class="fc" id="L233">              MAX_OPTIONS_JSON_LENGTH), &quot;OPTIONS_JSON_TOO_LONG&quot;);</span>
    }
    
    // Validar caracteres básicos do JSON
<span class="fc" id="L237">    String trimmed = optionsJson.trim();</span>
<span class="pc bpc" id="L238" title="2 of 4 branches missed.">    if (!trimmed.startsWith(&quot;{&quot;) || !trimmed.endsWith(&quot;}&quot;)) {</span>
<span class="nc" id="L239">      throw new SecurityValidationException(</span>
          &quot;Options must be a valid JSON object&quot;, &quot;INVALID_JSON_FORMAT&quot;);
    }
<span class="fc" id="L242">  }</span>

  /**
   * Valida parâmetros de paginação.
   *
   * @param page número da página
   * @param size tamanho da página
   * @throws SecurityValidationException se os parâmetros forem inválidos
   */
  public void validatePaginationParams(int page, int size) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (page &lt; 0) {</span>
<span class="fc" id="L253">      throw new SecurityValidationException(</span>
          &quot;Page number must be non-negative&quot;, &quot;INVALID_PAGE_NUMBER&quot;);
    }
    
<span class="fc bfc" id="L257" title="All 4 branches covered.">    if (size &lt; 1 || size &gt; 100) {</span>
<span class="fc" id="L258">      throw new SecurityValidationException(</span>
          &quot;Page size must be between 1 and 100&quot;, &quot;INVALID_PAGE_SIZE&quot;);
    }
<span class="fc" id="L261">  }</span>

  /**
   * Valida ID de job.
   *
   * @param jobId ID do job
   * @throws SecurityValidationException se o ID for inválido
   */
  public void validateJobId(String jobId) {
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">    if (jobId == null || jobId.trim().isEmpty()) {</span>
<span class="fc" id="L271">      throw new SecurityValidationException(</span>
          &quot;Job ID is required&quot;, &quot;MISSING_JOB_ID&quot;);
    }
    
<span class="fc bfc" id="L275" title="All 2 branches covered.">    if (!UUID_PATTERN.matcher(jobId).matches()) {</span>
<span class="fc" id="L276">      throw new SecurityValidationException(</span>
          &quot;Job ID must be a valid UUID&quot;, &quot;INVALID_JOB_ID_FORMAT&quot;);
    }
<span class="fc" id="L279">  }</span>

  /**
   * Valida se pelo menos um tipo de entrada foi fornecido.
   *
   * @param files arquivos enviados
   * @param inputFiles caminhos de arquivos existentes
   * @throws SecurityValidationException se nenhuma entrada for fornecida
   */
  public void validateInputProvided(List&lt;MultipartFile&gt; files, List&lt;String&gt; inputFiles) {
<span class="pc bpc" id="L289" title="2 of 8 branches missed.">    boolean hasFiles = files != null &amp;&amp; !files.isEmpty() &amp;&amp; files.stream().anyMatch(f -&gt; !f.isEmpty());</span>
<span class="fc bfc" id="L290" title="All 4 branches covered.">    boolean hasInputFiles = inputFiles != null &amp;&amp; !inputFiles.isEmpty();</span>
    
<span class="fc bfc" id="L292" title="All 4 branches covered.">    if (!hasFiles &amp;&amp; !hasInputFiles) {</span>
<span class="fc" id="L293">      throw new SecurityValidationException(</span>
          &quot;Either files or inputFiles parameter is required&quot;, &quot;NO_INPUT_PROVIDED&quot;);
    }
    
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">    if (hasFiles &amp;&amp; hasInputFiles) {</span>
<span class="nc" id="L298">      throw new SecurityValidationException(</span>
          &quot;Cannot provide both files and inputFiles parameters simultaneously&quot;, 
          &quot;CONFLICTING_INPUT_TYPES&quot;);
    }
<span class="fc" id="L302">  }</span>

  /**
   * Extrai a extensão de um arquivo.
   *
   * @param filename nome do arquivo
   * @return extensão do arquivo (incluindo o ponto)
   */
  private String getFileExtension(String filename) {
<span class="fc" id="L311">    int lastDotIndex = filename.lastIndexOf('.');</span>
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">    if (lastDotIndex == -1 || lastDotIndex == filename.length() - 1) {</span>
<span class="nc" id="L313">      return &quot;&quot;;</span>
    }
<span class="fc" id="L315">    return filename.substring(lastDotIndex);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>